% Add your standard header here.
%
-module(class_MyClass).


% Determines what are the mother classes of this class (if any):
-define( wooper_superclasses, [ class_DirectMotherOne, class_DirectMotherTwo ] ).


% Parameters taken by the constructor ('construct').
-define( wooper_construct_parameters, ).


% Declaring all variations of WOOPER standard life-cycle operations:
% (template pasted, two replacements performed to update arities)
-define( wooper_construct_export, new/X, new_link/X,
		synchronous_new/X, synchronous_new_link/X,
		synchronous_timed_new/X, synchronous_timed_new_link/X,
		remote_new/X+1, remote_new_link/X+1, remote_synchronous_new/X+1,
		remote_synchronous_new_link/X+1, remote_synchronous_timed_new/X+1,
		remote_synchronous_timed_new_link/X+1, construct/X+1, destruct/1 ).


% Member method declarations.
-define( wooper_method_export, myRequest/A1, myOneway/A2 ).


% Static method declarations.
-define( wooper_static_method_export, my_static_method/A3 ).


% Allows to define WOOPER base variables and methods for that class:
-include("wooper.hrl").


% Constructs a new instance of MyClass.
construct( State, ?wooper_construct_parameters ) ->

	% First the direct mother classes:
	MotherOneState = class_DirectMotherOne:construct( State, P1, P2, ...  ),

	MotherTwoState = class_DirectMotherTwo:construct( MotherOneState, P3,  ...  ),

	% Then the class-specific construction:

	[...]

	AnotherState = setAttributes( MotherTwoState, [
		 { my_attribute, 24 },
		 { other, "This is a message" } ] ),

	AnotherState.



% Overriden destructor.
destruct( State ) ->

	% Class-specific actions:
	[...]

	% Then call the direct mother class counterparts, and allow chaining:
	FinalState.



% Member method section.


myRequest( State, X, Y ) ->
	[...]
	?wooper_return_state_result( AState, AResult ).


myOneway( State, Z ) ->
	[...]
	?wooper_return_state_only( SomeState ).


% Static method section.

my_static_method( A, B, C ) ->
	[...]


% Helper functions section.

my_helper(N) ->
	[...]
