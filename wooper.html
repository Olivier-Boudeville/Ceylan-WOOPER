<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.14: http://docutils.sourceforge.net/" />
<title>Welcome to the WOOPER documentation</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7952 2016-07-26 18:15:59Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

.subscript {
  vertical-align: sub;
  font-size: smaller }

.superscript {
  vertical-align: super;
  font-size: smaller }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left, table.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right, table.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

table.align-center {
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

.align-top    {
  vertical-align: top }

.align-middle {
  vertical-align: middle }

.align-bottom {
  vertical-align: bottom }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document">


<span class="target" id="top"></span><!-- comment stylesheet specified through GNUmakefile -->
<!-- Note: Not able to obtain a proper Pygments support for code extract (ex: no colors). -->
<!-- comment Would appear too late, can only be an be used only in preamble: -->
<!-- comment :raw-latex:`\usepackage{graphicx}` -->
<!-- comment As a result, in this document at least a '.. figure:: XXXX' must -->
<!-- exist, otherwise: 'Undefined control sequence \includegraphics.'. -->
<p><span class="raw-html"><a name="wooper_top"></a></span></p>
<p><span class="raw-html"><div class="banner"><p><em>WOOPER documentation</em> <a href="http://wooper.esperide.org">browse latest</a> <a href="https://olivier-boudeville.github.io/Ceylan-WOOPER/wooper.html">browse mirror</a> <a href="wooper.pdf">get PDF</a> <a href="#wooper_top">go to top</a> <a href="#wooper_bottom">go to bottom</a> <a href="mailto:about(dash)wooper(at)esperide(dot)com?subject=[WOOPER]%20Remark">mail us</a></p></div></span></p>
<p><span class="raw-html"><center><img src="wooper-title.png" width="70%"></img></center></span>
</p>
<!-- comment Note: this is the latest, current version of the WOOPER 1.x documentation. As for WOOPER 2.0, all the available relevant bits are here as well, yet commented-out. -->
<div class="section" id="wrapper-for-object-oriented-programming-in-erlang">
<h1><a class="toc-backref" href="#id29"><em>Wrapper for Object-Oriented Programming in Erlang</em></a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Organisation:</th><td class="field-body">Copyright (C) 2008-2018 Olivier Boudeville</td>
</tr>
<tr class="field"><th class="field-name">Contact:</th><td class="field-body">about (dash) wooper (at) esperide (dot) com</td>
</tr>
<tr class="field"><th class="field-name">Creation Date:</th><td class="field-body">Thursday, February 25, 2008</td>
</tr>
<tr class="field"><th class="field-name">Lastly Updated:</th><td class="field-body">Saturday, March 10, 2018</td>
</tr>
</tbody>
</table>
<p>The latest version of this documentation is to be found at the <a class="reference external" href="http://wooper.esperide.org">official WOOPER website</a> (<tt class="docutils literal"><span class="pre">http://wooper.esperide.org</span></tt>).</p>
<p><span class="raw-html">This WOOPER documentation is also available in the PDF format (see <a href="wooper.pdf">wooper.pdf</a>), and mirrored <a href="http://olivier-boudeville.github.io/Ceylan-WOOPER/wooper.html">here</a>.</span></p>
<p></p>
<p></p>
<div class="contents topic" id="id1">
<span id="table-of-contents"></span><p class="topic-title first">Table of Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#wrapper-for-object-oriented-programming-in-erlang" id="id29"><em>Wrapper for Object-Oriented Programming in Erlang</em></a><ul>
<li><a class="reference internal" href="#overview" id="id30">Overview</a></li>
<li><a class="reference internal" href="#understanding-wooper-in-two-steps" id="id31">Understanding WOOPER in Two Steps</a><ul>
<li><a class="reference internal" href="#motivations-purpose" id="id32">Motivations &amp; Purpose</a></li>
<li><a class="reference internal" href="#the-wooper-mode-of-operation-in-a-nutshell" id="id33">The WOOPER Mode of Operation in a Nutshell</a></li>
<li><a class="reference internal" href="#id2" id="id34">Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#why-adding-object-oriented-capabilities-to-erlang" id="id35">Why Adding Object-Oriented Capabilities To Erlang?</a></li>
<li><a class="reference internal" href="#how-to-use-wooper-detailed-description-concept-mappings" id="id36">How to Use WOOPER: Detailed Description &amp; Concept Mappings</a><ul>
<li><a class="reference internal" href="#classes" id="id37">Classes</a></li>
<li><a class="reference internal" href="#instances" id="id38">Instances</a></li>
<li><a class="reference internal" href="#methods" id="id39">Methods</a></li>
<li><a class="reference internal" href="#id13" id="id40">State Management</a></li>
<li><a class="reference internal" href="#multiple-inheritance-polymorphism" id="id41">Multiple Inheritance &amp; Polymorphism</a></li>
<li><a class="reference internal" href="#life-cycle" id="id42">Life-Cycle</a></li>
</ul>
</li>
<li><a class="reference internal" href="#miscellaneous-technical-points" id="id43">Miscellaneous Technical Points</a><ul>
<li><a class="reference internal" href="#delete-any-instance-referenced-in-2" id="id44"><tt class="docutils literal">delete_any_instance_referenced_in/2</tt></a></li>
<li><a class="reference internal" href="#exit-messages" id="id45"><tt class="docutils literal">EXIT</tt> Messages</a></li>
<li><a class="reference internal" href="#monitors" id="id46">Monitors</a></li>
<li><a class="reference internal" href="#id21" id="id47">Type Specifications</a></li>
<li><a class="reference internal" href="#guidelines" id="id48">Guidelines</a></li>
<li><a class="reference internal" href="#source-editors" id="id49">Source Editors</a></li>
<li><a class="reference internal" href="#similarity-with-other-languages" id="id50">Similarity With Other Languages</a></li>
</ul>
</li>
<li><a class="reference internal" href="#wooper-example" id="id51">WOOPER Example</a><ul>
<li><a class="reference internal" href="#class-implementations" id="id52">Class implementations</a></li>
<li><a class="reference internal" href="#tests" id="id53">Tests</a></li>
</ul>
</li>
<li><a class="reference internal" href="#good-practises" id="id54">Good Practises</a></li>
<li><a class="reference internal" href="#troubleshooting" id="id55">Troubleshooting</a><ul>
<li><a class="reference internal" href="#general-case" id="id56">General Case</a></li>
</ul>
</li>
<li><a class="reference internal" href="#current-stable-version-download" id="id57">Current Stable Version &amp; Download</a><ul>
<li><a class="reference internal" href="#using-stable-release-archive" id="id58">Using Stable Release Archive</a></li>
<li><a class="reference internal" href="#using-cutting-edge-git" id="id59">Using Cutting-Edge GIT</a></li>
</ul>
</li>
<li><a class="reference internal" href="#version-history-changes" id="id60">Version History &amp; Changes</a><ul>
<li><a class="reference internal" href="#version-2-0-cutting-edge-not-available" id="id61">Version 2.0 [cutting-edge, not available]</a></li>
<li><a class="reference internal" href="#version-1-0-current-stable" id="id62">Version 1.0 [current stable]</a></li>
<li><a class="reference internal" href="#version-0-4" id="id63">Version 0.4</a></li>
<li><a class="reference internal" href="#version-0-3" id="id64">Version 0.3</a></li>
<li><a class="reference internal" href="#version-0-2" id="id65">Version 0.2</a></li>
<li><a class="reference internal" href="#version-0-1" id="id66">Version 0.1</a></li>
</ul>
</li>
<li><a class="reference internal" href="#wooper-inner-workings" id="id67">WOOPER Inner Workings</a><ul>
<li><a class="reference internal" href="#method-virtual-table" id="id68">Method Virtual Table</a></li>
<li><a class="reference internal" href="#attribute-table" id="id69">Attribute Table</a></li>
</ul>
</li>
<li><a class="reference internal" href="#issues-planned-enhancements" id="id70">Issues &amp; Planned Enhancements</a></li>
<li><a class="reference internal" href="#licence" id="id71">Licence</a></li>
<li><a class="reference internal" href="#sources-inspirations-alternate-solutions" id="id72">Sources, Inspirations &amp; Alternate Solutions</a></li>
<li><a class="reference internal" href="#support" id="id73">Support</a></li>
<li><a class="reference internal" href="#please-react" id="id74">Please React!</a></li>
<li><a class="reference internal" href="#ending-word" id="id75">Ending Word</a></li>
</ul>
</li>
</ul>
</div>
<p></p>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id30">Overview</a></h2>
<p>WOOPER, which stands for <em>Wrapper for Object-Oriented Programming in Erlang</em>, is a <a class="reference internal" href="#free-software">free software</a> lightweight layer on top of the <a class="reference external" href="http://erlang.org">Erlang</a> language that provides constructs dedicated to <a class="reference external" href="http://en.wikipedia.org/wiki/Object-oriented_programming">Object-Oriented Programming</a> (OOP).</p>
<p>WOOPER is a rather autonomous part of the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan">Ceylan</a> project.</p>
<p>At least a basic knowledge of Erlang is expected in order to use WOOPER.</p>
</div>
<div class="section" id="understanding-wooper-in-two-steps">
<h2><a class="toc-backref" href="#id31">Understanding WOOPER in Two Steps</a></h2>
<p>Here is a <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/examples/class_Cat.erl">class definition</a>, and here is an example of <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/examples/class_Cat_test.erl">code using it</a>. That's it!</p>
<p>Now, let's discuss a bit more in-depth of these subjects.</p>
<div class="section" id="motivations-purpose">
<h3><a class="toc-backref" href="#id32">Motivations &amp; Purpose</a></h3>
<p>Some problems may almost only be tackled efficiently thanks to an object-oriented modelling.</p>
<p>The set of code and conventions proposed here allows to benefit from all the main OOP features (including polymorphism, life cycle management, state management and multiple inheritance) directly from Erlang (which natively does not rely on the OOP paradigm), so that - in the cases where it makes sense - an object-oriented approach at the implementation level can be easily achieved.</p>
</div>
<div class="section" id="the-wooper-mode-of-operation-in-a-nutshell">
<h3><a class="toc-backref" href="#id33">The WOOPER Mode of Operation in a Nutshell</a></h3>
<p>The WOOPER OOP concepts translate into Erlang constructs according to the following mapping:</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">WOOPER base concept</th>
<th class="head">Corresponding mapping to Erlang</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>class definition</td>
<td>module (typically compiled in a <tt class="docutils literal">.beam</tt> file)</td>
</tr>
<tr><td>instance</td>
<td>process</td>
</tr>
<tr><td>instance reference</td>
<td>process identifier (PID)</td>
</tr>
<tr><td>new operators</td>
<td>WOOPER-provided functions, making use of user-defined <tt class="docutils literal">construct/N</tt> functions (a.k.a. the constructors)</td>
</tr>
<tr><td>delete operator</td>
<td>WOOPER-provided function, making use of any user-defined <tt class="docutils literal">destruct/1</tt> (a.k.a. the destructor)</td>
</tr>
<tr><td>method definition</td>
<td>module function that respects some conventions</td>
</tr>
<tr><td>method invocation</td>
<td>sending of an appropriate inter-process message</td>
</tr>
<tr><td>method look-up</td>
<td>class-specific virtual table taking into account inheritance transparently</td>
</tr>
<tr><td>instance state</td>
<td>instance-specific datastructure storing its attributes, and kept by the instance-specific WOOPER tail-recursive infinite loop</td>
</tr>
<tr><td>instance attributes</td>
<td>key/value pairs stored in the instance state</td>
</tr>
<tr><td>class (static) method</td>
<td>exported module function</td>
</tr>
</tbody>
</table>
<p>In practice, developing a class with WOOPER mostly involves including the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/src/wooper.hrl">wooper.hrl</a> header file and respecting the WOOPER conventions detailed below.</p>
</div>
<div class="section" id="id2">
<span id="example"></span><h3><a class="toc-backref" href="#id34">Example</a></h3>
<p>Here is a simple example of how a WOOPER class can be defined and used.</p>
<p>It shows <tt class="docutils literal">new/delete</tt> operators, method calling (both request and oneway), and inheritance.</p>
<p>A cat is here a viviparous mammal, as defined below (this is a variation of our more complete <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/examples/class_Cat.erl">class_Cat.erl</a> example):</p>
<pre class="code erlang literal-block">
<span class="punctuation">-</span><span class="name entity">module</span><span class="punctuation">(</span><span class="name">class_Cat</span><span class="punctuation">).</span>

<span class="comment">% Determines what are the mother classes of this class (if any):
</span><span class="punctuation">-</span><span class="name entity">define</span><span class="punctuation">(</span><span class="name constant">wooper_superclasses</span><span class="punctuation">,[</span><span class="name">class_Mammal</span><span class="punctuation">,</span><span class="name">class_ViviparousBeing</span><span class="punctuation">]).</span>

<span class="comment">% Parameters taken by the constructor ('construct').
% They are here the ones of the Mammal mother class (the viviparous being
% constructor does not need any parameter) plus whisker color.
% These are class-specific data needing to be set in the constructor:
</span><span class="punctuation">-</span><span class="name entity">define</span><span class="punctuation">(</span><span class="name constant">wooper_construct_parameters</span><span class="punctuation">,</span><span class="name variable">Age</span><span class="punctuation">,</span><span class="name variable">Gender</span><span class="punctuation">,</span><span class="name variable">FurColor</span><span class="punctuation">,</span><span class="name variable">WhiskerColor</span><span class="punctuation">).</span>

<span class="comment">% Declaring all variations of WOOPER standard life-cycle operations:
% (this is just a pasted template, with updated arities)
</span><span class="punctuation">-</span><span class="name entity">define</span><span class="punctuation">(</span> <span class="name">wooper_construct_export</span><span class="punctuation">,</span> <span class="name">new</span><span class="operator">/</span><span class="literal number integer">4</span><span class="punctuation">,</span> <span class="name">new_link</span><span class="operator">/</span><span class="literal number integer">4</span><span class="punctuation">,</span>
       <span class="name">synchronous_new</span><span class="operator">/</span><span class="literal number integer">4</span><span class="punctuation">,</span> <span class="name">synchronous_new_link</span><span class="operator">/</span><span class="literal number integer">4</span><span class="punctuation">,</span>
       <span class="name">synchronous_timed_new</span><span class="operator">/</span><span class="literal number integer">4</span><span class="punctuation">,</span> <span class="name">synchronous_timed_new_link</span><span class="operator">/</span><span class="literal number integer">4</span><span class="punctuation">,</span>
       <span class="name">remote_new</span><span class="operator">/</span><span class="literal number integer">5</span><span class="punctuation">,</span> <span class="name">remote_new_link</span><span class="operator">/</span><span class="literal number integer">5</span><span class="punctuation">,</span> <span class="name">remote_synchronous_new</span><span class="operator">/</span><span class="literal number integer">5</span><span class="punctuation">,</span>
       <span class="name">remote_synchronous_new_link</span><span class="operator">/</span><span class="literal number integer">5</span><span class="punctuation">,</span> <span class="name">remote_synchronous_timed_new</span><span class="operator">/</span><span class="literal number integer">5</span><span class="punctuation">,</span>
       <span class="name">remote_synchronous_timed_new_link</span><span class="operator">/</span><span class="literal number integer">5</span><span class="punctuation">,</span> <span class="name">construct</span><span class="operator">/</span><span class="literal number integer">5</span><span class="punctuation">,</span> <span class="name">destruct</span><span class="operator">/</span><span class="literal number integer">1</span> <span class="punctuation">).</span>

<span class="comment">% Member method declarations:
</span><span class="punctuation">-</span><span class="name entity">define</span><span class="punctuation">(</span> <span class="name">wooper_method_export</span><span class="punctuation">,</span><span class="name">getWhiskerColor</span><span class="operator">/</span><span class="literal number integer">1</span><span class="punctuation">,</span><span class="name">setWhiskerColor</span><span class="operator">/</span><span class="literal number integer">2</span><span class="punctuation">,</span>
       <span class="name">canEat</span><span class="operator">/</span><span class="literal number integer">2</span> <span class="punctuation">).</span>

<span class="comment">% Static method declarations:
</span><span class="punctuation">-</span><span class="name entity">define</span><span class="punctuation">(</span> <span class="name">wooper_static_method_export</span><span class="punctuation">,</span> <span class="name">get_default_whisker_color</span><span class="punctuation">()</span><span class="operator">/</span><span class="literal number integer">0</span> <span class="punctuation">).</span>

<span class="comment">% Allows to define WOOPER base variables and methods for that class:
</span><span class="punctuation">-</span><span class="name entity">include</span><span class="punctuation">(</span><span class="literal string">&quot;wooper.hrl&quot;</span><span class="punctuation">).</span>

<span class="comment">% Constructs a new Cat.
</span><span class="name function">construct</span><span class="punctuation">(</span> <span class="name variable">State</span><span class="punctuation">,</span> <span class="operator">?</span><span class="name">wooper_construct_parameters</span> <span class="punctuation">)</span> <span class="operator">-&gt;</span>
       <span class="comment">% First the direct mother classes:
</span>       <span class="name variable">MammalState</span> <span class="operator">=</span> <span class="name namespace">class_Mammal</span><span class="punctuation">:</span><span class="name function">construct</span><span class="punctuation">(</span> <span class="name variable">State</span><span class="punctuation">,</span> <span class="name variable">Age</span><span class="punctuation">,</span> <span class="name variable">Gender</span><span class="punctuation">,</span> <span class="name variable">FurColor</span> <span class="punctuation">),</span>
       <span class="name variable">ViviparousMammalState</span> <span class="operator">=</span> <span class="name namespace">class_ViviparousBeing</span><span class="punctuation">:</span><span class="name function">construct</span><span class="punctuation">(</span><span class="name variable">MammalState</span><span class="punctuation">),</span>
       <span class="comment">% Then the class-specific attributes; returns an updated state:
</span>       <span class="name">setAttributes</span><span class="punctuation">(</span> <span class="name variable">ViviparousMammalState</span><span class="punctuation">,</span> <span class="name">whisker_color</span><span class="punctuation">,</span> <span class="name variable">WhiskerColor</span> <span class="punctuation">).</span>

<span class="name function">destruct</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
       <span class="name namespace">io</span><span class="punctuation">:</span><span class="name function">format</span><span class="punctuation">(</span> <span class="literal string">&quot;Deleting cat </span><span class="literal string interpol">~w</span><span class="literal string">! (overridden destructor)</span><span class="literal string interpol">~n</span><span class="literal string">&quot;</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="name">self</span><span class="punctuation">()]</span> <span class="punctuation">),</span>
       <span class="name variable">State</span><span class="punctuation">.</span>

<span class="comment">% Member methods.
</span>
<span class="comment">% A cat-specific const request:
</span><span class="name function">getWhiskerColor</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">)</span><span class="operator">-&gt;</span>
       <span class="operator">?</span><span class="name">wooper_return_state_result</span><span class="punctuation">(</span> <span class="name variable">State</span><span class="punctuation">,</span> <span class="operator">?</span><span class="name">getAttr</span><span class="punctuation">(</span><span class="name">whisker_color</span><span class="punctuation">)</span> <span class="punctuation">).</span>

<span class="comment">% A (non-const) oneway:
</span><span class="name function">setWhiskerColor</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name variable">NewColor</span><span class="punctuation">)</span><span class="operator">-&gt;</span>
       <span class="name variable">NewState</span> <span class="operator">=</span> <span class="name">setAttribute</span><span class="punctuation">(</span> <span class="name variable">State</span><span class="punctuation">,</span> <span class="name">whisker_color</span><span class="punctuation">,</span> <span class="name variable">NewColor</span> <span class="punctuation">),</span>
       <span class="operator">?</span><span class="name">wooper_return_state_only</span><span class="punctuation">(</span> <span class="name variable">NewState</span> <span class="punctuation">).</span>

<span class="comment">% Overrides any request method defined in the Mammal class:
% (const request)
</span><span class="name function">canEat</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name">soup</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
       <span class="operator">?</span><span class="name">wooper_return_state_result</span><span class="punctuation">(</span> <span class="name variable">State</span><span class="punctuation">,</span> <span class="name">true</span> <span class="punctuation">);</span>

<span class="name function">canEat</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name">croquette</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
       <span class="operator">?</span><span class="name">wooper_return_state_result</span><span class="punctuation">(</span> <span class="name variable">State</span><span class="punctuation">,</span> <span class="name">true</span> <span class="punctuation">);</span>

<span class="name function">canEat</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name">meat</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
       <span class="operator">?</span><span class="name">wooper_return_state_result</span><span class="punctuation">(</span> <span class="name variable">State</span><span class="punctuation">,</span> <span class="name">true</span> <span class="punctuation">);</span>

<span class="name function">canEat</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,_</span><span class="name variable">OtherFood</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
       <span class="operator">?</span><span class="name">wooper_return_state_result</span><span class="punctuation">(</span> <span class="name variable">State</span><span class="punctuation">,</span> <span class="name">false</span> <span class="punctuation">).</span>

<span class="comment">% Static method:
</span><span class="name function">get_default_whisker_color</span><span class="punctuation">()</span> <span class="operator">-&gt;</span>
       <span class="name">white</span><span class="punctuation">.</span>
</pre>
<p>Straightforward, isn't it? We will discuss it in-depth, though.</p>
<p>To test this class (provided that <tt class="docutils literal">GNU make</tt> and <tt class="docutils literal">Erlang 20.0</tt> or more recent are available in one's environment), one can easily install <tt class="docutils literal"><span class="pre">Ceylan-WOOPER</span></tt>, which depends on <tt class="docutils literal"><span class="pre">Ceylan-Myriad</span></tt>, hence to be installed first:</p>
<pre class="code bash literal-block">
$ git clone https://github.com/Olivier-Boudeville/Ceylan-Myriad.git
$ <span class="name builtin">cd</span> Ceylan-Myriad <span class="operator">&amp;&amp;</span> make all <span class="operator">&amp;&amp;</span> <span class="name builtin">cd</span> ..
</pre>
<p>Then, as <tt class="docutils literal"><span class="pre">Ceylan-Myriad</span></tt> is known by WOOPER as the <tt class="docutils literal">Common</tt> layer:</p>
<pre class="code bash literal-block">
$ ln -s Ceylan-Myriad common
$ git clone https://github.com/Olivier-Boudeville/Ceylan-WOOPER.git
$ <span class="name builtin">cd</span> Ceylan-WOOPER <span class="operator">&amp;&amp;</span> make all
</pre>
<p>Running the cat-related example just boils down to:</p>
<pre class="code bash literal-block">
$ <span class="name builtin">cd</span> examples <span class="operator">&amp;&amp;</span> make class_Cat_run
</pre>
<p>In the <tt class="docutils literal">examples</tt> directory, the test defined in <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/examples/class_Cat_test.erl">class_Cat_test.erl</a> should run against the class defined in <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/examples/class_Cat.erl">class_Cat.erl</a>, and no error should be detected:</p>
<pre class="code bash literal-block">
Running unitary <span class="name builtin">test</span> class_Cat_run <span class="operator">(</span>second form<span class="operator">)</span>
Erlang/OTP <span class="literal number">20</span> <span class="operator">[</span>erts-9.0.1<span class="operator">]</span> <span class="operator">[</span>source<span class="operator">]</span> <span class="operator">[</span><span class="literal number">64</span>-bit<span class="operator">]</span> <span class="operator">[</span>smp:8:8<span class="operator">]</span> <span class="operator">[</span>..<span class="operator">]</span>
--&gt; Testing module class_Cat_test.
<span class="operator">[</span>..<span class="operator">]</span>
Deleting cat &lt;<span class="literal number">0</span>.70.0&gt;! <span class="operator">(</span>overridden destructor<span class="operator">)</span>
Deleting mammal &lt;<span class="literal number">0</span>.68.0&gt;! <span class="operator">(</span>overridden destructor<span class="operator">)</span>
Actual class from destructor: class_Cat.
Deleting mammal &lt;<span class="literal number">0</span>.70.0&gt;! <span class="operator">(</span>overridden destructor<span class="operator">)</span>
This cat could be created and be synchronously deleted, as expected.
--&gt; Successful end of test.
<span class="operator">(</span><span class="name builtin">test</span> finished, interpreter halted<span class="operator">)</span>
</pre>
<p>That's it!</p>
<p>Now, more in-depth explanations.</p>
<p></p>
</div>
</div>
<div class="section" id="why-adding-object-oriented-capabilities-to-erlang">
<h2><a class="toc-backref" href="#id35">Why Adding Object-Oriented Capabilities To Erlang?</a></h2>
<p>Although applying blindly an OOP approach while using languages based on other paradigms (Erlang ones are functional and concurrent; the language is not specifically targeting OOP) is a common mistake, there are some problems that may be deemed inherently &quot;object-oriented&quot;, i.e. that cannot be effectively modelled without encapsulated abstractions sharing behaviours.</p>
<p>Examples of this kind of systems are multi-agent simulations. If they often need massive concurrency, robustness, distribution, etc. (Erlang is particularly suitable for that), the various types of agents have also often to largely share states and behaviours, while still being able to be further specialised on a per-type basis.</p>
<p>The <a class="reference internal" href="#example">example</a> mentioned in this document is an illustration <a class="footnote-reference" href="#id4" id="id3">[1]</a> of the interacting lives of numerous animals of various species. Obviously, they have to share behaviours (ex: all ovoviviparous beings may lay eggs, all creatures can live and die, all have an age, etc.), which cannot be mapped easily (read: automatically) to Erlang concepts without adding some generic constructs.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>This example is not a <em>simulation</em>, it is just a multi-agent system. For real, massive, discrete-time simulations of complex systems in Erlang (using WOOPER), one may refer to <a class="reference external" href="http://www.sim-diasca.com">Sim-Diasca</a>.</td></tr>
</tbody>
</table>
<p>WOOPER, which stands for <em>Wrapper for OOP in Erlang</em>, is a lightweight yet effective (performance-wise, but also regarding the overall developing efforts) means of making these constructs available, notably in terms of state management and multiple inheritance.</p>
<p>The same programs could certainly be implemented without such OOP constructs, but at the expense of way too much manually-crafted, specific (per-class) code. This process would be tedious, error-prone, and most often the result could hardly be maintained.</p>
<p></p>
</div>
<div class="section" id="how-to-use-wooper-detailed-description-concept-mappings">
<h2><a class="toc-backref" href="#id36">How to Use WOOPER: Detailed Description &amp; Concept Mappings</a></h2>
<!-- comment May trigger following error: 'LaTeX Error: File `minitoc.sty' not found.':
Use: 'pacman -S texlive-latexextra' then. -->
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#classes" id="id76">Classes</a><ul>
<li><a class="reference internal" href="#classes-names" id="id77">Classes &amp; Names</a></li>
<li><a class="reference internal" href="#inheritance-superclasses" id="id78">Inheritance &amp; Superclasses</a></li>
</ul>
</li>
<li><a class="reference internal" href="#instances" id="id79">Instances</a><ul>
<li><a class="reference internal" href="#instance-mapping" id="id80">Instance Mapping</a></li>
<li><a class="reference internal" href="#instance-state" id="id81">Instance State</a></li>
</ul>
</li>
<li><a class="reference internal" href="#methods" id="id82">Methods</a><ul>
<li><a class="reference internal" href="#method-declaration" id="id83">Method Declaration</a></li>
<li><a class="reference internal" href="#method-invocation" id="id84">Method Invocation</a></li>
<li><a class="reference internal" href="#method-name" id="id85">Method Name</a></li>
<li><a class="reference internal" href="#method-parameters" id="id86">Method Parameters</a></li>
<li><a class="reference internal" href="#two-kinds-of-methods" id="id87">Two Kinds of Methods</a></li>
<li><a class="reference internal" href="#method-results" id="id88">Method Results</a></li>
<li><a class="reference internal" href="#method-definition" id="id89">Method Definition</a></li>
<li><a class="reference internal" href="#self-invocation-calling-a-method-from-the-instance-itself" id="id90">Self-Invocation: Calling a Method From The Instance Itself</a></li>
<li><a class="reference internal" href="#static-methods" id="id91">Static Methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id13" id="id92">State Management</a><ul>
<li><a class="reference internal" href="#principles" id="id93">Principles</a></li>
<li><a class="reference internal" href="#state-implementation-details" id="id94">State Implementation Details</a></li>
<li><a class="reference internal" href="#managing-the-state-of-an-instance" id="id95">Managing The State Of An Instance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#multiple-inheritance-polymorphism" id="id96">Multiple Inheritance &amp; Polymorphism</a><ul>
<li><a class="reference internal" href="#the-general-case" id="id97">The General Case</a></li>
<li><a class="reference internal" href="#the-special-case-of-diamond-shaped-inheritance" id="id98">The Special Case of Diamond-Shaped Inheritance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#life-cycle" id="id99">Life-Cycle</a><ul>
<li><a class="reference internal" href="#instance-creation-new-new-link-and-construct" id="id100">Instance Creation: <tt class="docutils literal">new</tt>/<tt class="docutils literal">new_link</tt> And <tt class="docutils literal">construct</tt></a></li>
<li><a class="reference internal" href="#instance-deletion" id="id101">Instance Deletion</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="classes">
<h3><a class="toc-backref" href="#id76">Classes</a></h3>
<div class="section" id="classes-names">
<h4><a class="toc-backref" href="#id77">Classes &amp; Names</a></h4>
<p>A class is a blueprint to create objects, a common scheme describing the state and behaviour of its instances, i.e. the attributes and methods that the created objects for that class all have.</p>
<p>With WOOPER, each class has a unique name, such as <tt class="docutils literal">class_Cat</tt>.</p>
<p>To allow for <strong>encapsulation</strong>, a WOOPER class is mapped to an Erlang module, whose name is by convention made from the <tt class="docutils literal">class_</tt> prefix followed by the class name, in the so-called <a class="reference external" href="http://en.wikipedia.org/wiki/CamelCase">CamelCase</a>: all words are spelled in lower-case except their first letter, and there are no separators between words, like in: <em>ThisIsAnExample</em>.</p>
<p>For example, a class modeling a cat should translate into an Erlang module named <tt class="docutils literal">class_Cat</tt>, thus in a file named <tt class="docutils literal">class_Cat.erl</tt>. At the top of this file, the corresponding module would be therefore declared with: <tt class="docutils literal"><span class="pre">-module(class_Cat).</span></tt>.</p>
<p>Similarly, a pink flamingo class could be declared as <tt class="docutils literal">class_PinkFlamingo</tt>, in <tt class="docutils literal">class_PinkFlamingo.erl</tt>, which would include a <tt class="docutils literal"><span class="pre">-module(class_PinkFlamingo).</span></tt> declaration.</p>
<p>The class name can be obtained through its <tt class="docutils literal">get_class_name/0</tt> static method <a class="footnote-reference" href="#id6" id="id5">[2]</a> (automatically defined by WOOPER):</p>
<pre class="code erlang literal-block">
<span class="operator">&gt;</span> <span class="name namespace">class_Cat</span><span class="punctuation">:</span><span class="name function">get_class_name</span><span class="punctuation">().</span>
<span class="name">class_Cat</span>
</pre>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[2]</a></td><td>The <tt class="docutils literal">get_class_name/0</tt> static method has no real interest of its own, it is defined mostly for explanation purpose.</td></tr>
</tbody>
</table>
<p>Note that a static method (i.e. a class method that does not apply to any specific instance) of a class X is nothing more than an Erlang function exported from the corresponding <tt class="docutils literal">class_X</tt> module: all exported functions could be seen as static methods.</p>
</div>
<div class="section" id="inheritance-superclasses">
<h4><a class="toc-backref" href="#id78">Inheritance &amp; Superclasses</a></h4>
<p>A WOOPER class can inherit from other classes, in which case the state and behaviour defined in the mother classes are readily available to this child class.</p>
<p>Being in a <strong>multiple inheritance</strong> context, a given class can have any number (<tt class="docutils literal"><span class="pre">[0..n]</span></tt>) of direct mother classes, which themselves may have mother classes, and so on. This leads to a class hierarchy that forms a graph.</p>
<p>This is declared in WOOPER thanks to the <tt class="docutils literal">wooper_superclasses</tt> define. For example, a class with no mother class should specify, once having declared its module:</p>
<pre class="code erlang literal-block">
<span class="punctuation">-</span><span class="name entity">define</span><span class="punctuation">(</span><span class="name constant">wooper_superclasses</span><span class="punctuation">,[]).</span>
</pre>
<!-- comment This is declared in WOOPER thanks to the ``get_superclasses/0`` function. For example, a class with no mother class should specify, once having declared its module, ``get_superclasses() -> [].`` [#]_. -->
<!-- comment .. [#] Such WOOPER-related functions are already automatically exported by WOOPER. As an added bonus, this allows the class developer to be notified whenever he forgets to define them. -->
<p>As for our cat, this superb animal could be modelled both as a mammal (itself a specialised creature) and a viviparous being <a class="footnote-reference" href="#id8" id="id7">[3]</a>. Hence its direct inheritance could be defined as:</p>
<pre class="code erlang literal-block">
<span class="punctuation">-</span><span class="name entity">define</span><span class="punctuation">(</span><span class="name constant">wooper_superclasses</span><span class="punctuation">,[</span><span class="name">class_Mammal</span><span class="punctuation">,</span><span class="name">class_ViviparousBeing</span><span class="punctuation">]).</span>
</pre>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[3]</a></td><td>Neither of them is a subset of the other, these are mostly unrelated concepts, at least in the context of that example! (ex: a platypus is a mammal, but not a viviparous being).</td></tr>
</tbody>
</table>
<p>The superclasses (direct mother classes) of a given class can be known thanks to its <tt class="docutils literal">get_superclasses/0</tt> static method:</p>
<pre class="code erlang literal-block">
<span class="operator">&gt;</span> <span class="name namespace">class_Cat</span><span class="punctuation">:</span><span class="name function">get_superclasses</span><span class="punctuation">().</span>
<span class="punctuation">[</span><span class="name">class_Mammal</span><span class="punctuation">,</span><span class="name">class_ViviparousBeing</span><span class="punctuation">]</span>
</pre>
<!-- comment Note::  We will discuss here mostly the WOOPER versions 2.x and higher, originating from a development branch that is sometimes codenamed the "*Zero-Overhead WOOPER*", as opposed to the legacy versions (prior to 2.x), codenamed "*Hashtable-based WOOPER*". -->
</div>
</div>
<div class="section" id="instances">
<h3><a class="toc-backref" href="#id79">Instances</a></h3>
<div class="section" id="instance-mapping">
<h4><a class="toc-backref" href="#id80">Instance Mapping</a></h4>
<p>With WOOPER, which focuses on multi-agent systems, all <strong>instances</strong> of a class are mapped to Erlang processes (one WOOPER instance is exactly one Erlang process).</p>
<p>They are therefore, in UML parlance, <em>active objects</em> (each has its own thread of execution, they may apparently &quot;live&quot; simultaneously <a class="footnote-reference" href="#id10" id="id9">[4]</a>).</p>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[4]</a></td><td><p class="first">For some uses, such a concurrent feature (with <em>active</em> instances) may not be needed, in which case one may deal also with purely <em>passive</em> instances (as Erlang terms, not Erlang processes).</p>
<p class="last">To anticipate a bit, instead of using <tt class="docutils literal">new/n</tt> (returning the PID of a new process instance looping over its state), one may rely on <tt class="docutils literal">construct/n+1</tt> (returning directly to the caller process that corresponding initial state, that can be then stored and interacted upon at will).</p>
</td></tr>
</tbody>
</table>
</div>
<div class="section" id="instance-state">
<h4><a class="toc-backref" href="#id81">Instance State</a></h4>
<p>Another common OOP need is to rely on <strong>state management</strong> and <strong>encapsulation</strong>: each instance should be stateful, have its state fully private, and be able to inherit automatically the data members defined by its mother classes.</p>
<p>In WOOPER, this is obtained thanks to a per-instance associative table, whose keys are the names of attributes and whose values are the attribute values. This will be detailed in the <a class="reference internal" href="#state-management">state management</a> section.</p>
<p></p>
</div>
</div>
<div class="section" id="methods">
<h3><a class="toc-backref" href="#id82">Methods</a></h3>
<p>They can be either:</p>
<ul class="simple">
<li><strong>member methods</strong>: to be applied to a specific <em>instance</em> (of a given class), like in: <tt class="docutils literal">MyCat ! declareBirthday</tt></li>
<li>or <strong>static methods</strong>: general to a <em>class</em>, not targeting specifically an instance, like: <tt class="docutils literal">class_Cat:get_default_mew_duration()</tt></li>
</ul>
<p>Unless specified otherwise, just mentioning <em>method</em> by itself refers to a <em>member method</em>. Static methods are discussed into their specific subsection.</p>
<p><strong>Member methods</strong> can be publicly called by any process (be it WOOPER-based or not - provided of course it knows the PID of that instance), whether locally or remotely (i.e. on other networked computers, like with RMI or with CORBA, or directly from the same Erlang node), distribution (and parallelism) being seamlessly managed thanks to Erlang.</p>
<p>Member methods (either inherited or defined directly in the class) are mapped to specific Erlang functions, triggered by Erlang messages.</p>
<p>For example, our cat class may define, among others, following member methods (actual arities to be discussed later):</p>
<ul class="simple">
<li><tt class="docutils literal">canEat</tt>, taking one parameter specifying the type of food, and returning whether the corresponding cat can eat that kind of food; here the implementation should be cat-specific (i.e. specific to cats and also, possibly, specific to this very single cat), whereas the method signature shall be shared by all beings</li>
<li><tt class="docutils literal">getWhiskersColor</tt>, taking no parameter, returning the color of its whiskers; this is indeed a purely cat-specific method, and different cats may be different whisker colors; as this method, like the previous one, returns a result to the caller, it is a <em>request</em> method</li>
<li><tt class="docutils literal">declareBirthday</tt>, incrementing the age of our cat, not taking any parameter nor returning anything; it will be therefore be implemented as a <em>oneway</em> method (i.e. not returning any result to the caller, hence not even needing to know it), whose call is only interesting for its effect on the cat state: here, making it one year older</li>
<li><tt class="docutils literal">setWhiskerColor</tt>, assigning the specified color to the whiskers of that cat instance, not returning anything (another oneway method, then)</li>
</ul>
<p>Declaring a birthday is not cat-specific, nor mammal-specific: we can consider it being creature-specific. Cat instances should then inherit this method, preferably indirectly from the <tt class="docutils literal">class_Creature</tt> class, in all cases without having to specify anything, since the <tt class="docutils literal">wooper_superclasses</tt> define already implies it (implying one time for all that cats <em>are</em> creatures). Of course this inherited method may be overridden at will anywhere in the class hierarchy.</p>
<p>We will discuss the <em>definition</em> of these methods later, but for the moment let's determine their signatures and declarations, and how we are expected to <em>call</em> them.</p>
<div class="section" id="method-declaration">
<h4><a class="toc-backref" href="#id83">Method Declaration</a></h4>
<p>The cat-specific member (i.e. non-static) methods are to be declared:</p>
<ul class="simple">
<li>in the <tt class="docutils literal">class_Cat</tt> (defined as mentioned in <tt class="docutils literal">class_Cat.erl</tt>)</li>
<li>thanks to the <tt class="docutils literal">wooper_method_export</tt> define (which, as expected, automatically exports these member methods)</li>
</ul>
<p>Their arity should be equal to the number of parameters they should be called with, plus one that is automatically managed by WOOPER and corresponds to the (private) state of that instance.</p>
<p>This <tt class="docutils literal">State</tt> variable defined by WOOPER can be somehow compared to the <tt class="docutils literal">self</tt> parameter of Python, or to the <tt class="docutils literal">this</tt> hidden pointer of C++. That state is automatically kept by WOOPER instances in their main loop, and automatically prepended, as first element, to the parameters of incoming method calls.</p>
<p>In our example, the declarations could therefore result in:</p>
<pre class="code erlang literal-block">
<span class="punctuation">-</span><span class="name entity">define</span><span class="punctuation">(</span><span class="name constant">wooper_method_export</span><span class="punctuation">,</span> <span class="name">canEat</span><span class="operator">/</span><span class="literal number integer">2</span><span class="punctuation">,</span> <span class="name">getWhiskerColor</span><span class="operator">/</span><span class="literal number integer">1</span><span class="punctuation">,</span>
                <span class="name">setWhiskerColor</span><span class="operator">/</span><span class="literal number integer">2</span><span class="punctuation">).</span>
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In our example, <tt class="docutils literal">declareBirthday/1</tt> will be inherited but not overridden (its base implementation being fine for cats as well), so it should not be listed among the <tt class="docutils literal">class_Cat</tt> methods.</p>
</div>
<p>Some method names are reserved for WOOPER; notably no user method should have its name prefixed with <tt class="docutils literal">wooper</tt>.</p>
<!-- comment In our example, the declarations could therefore result in:
 get_member_methods() ->
       [ {getMewVolume,1}, {canEat,2, [public,final]},
         {getWhiskerColor,1,[public,const]}, {setWhiskerColor,2,protected} ].


More generally a member method can be declared with:

- just its name and full arity (including the ``State`` parameter), ex: ``{getMewVolume,1}``
- its name, full arity, and one qualifier, ex: ``{getWhiskerColor,1,public}``
- its name, full arity, and a list of qualifiers, ex: ``{canEat,2, [public,final]}``


Known method qualifiers are:

- in terms of accessibility:

 - ``public``: the method can be called from outside the instance as well as from the class itself, i.e. from the body of its own methods (inherited or not), or from its child classes
 - ``protected``: the method can be called only from the body of its own methods (inherited or not), or from its child classes; no call from outside the class
 - ``private``: the method can be called only from the body of its own methods (inherited or not); no call from outside the class or from child classes is allowed

 - in terms of mutability:

  - ``const``: a call to the method on an instance will then never result into a change in the state of that instance

  - ``final``: this method cannot be overridden by child classes

Unless specified otherwise, a method is public, non-const, non-final.



.. Note::

 WOOPER allows to *specify* these qualifiers for documentation purposes, but may or may not enforce them.

 For example, to anticipate a bit, all methods could be dispatched into three lists (for public/protected/private), and when an ``execute*`` call is performed, a check, based on the actual class of the instance, could be done.

 On the other hand, method calls, triggered by messages instead, could not have their access controlled (without even mentioning the runtime overhead). For example, protected oneways cannot be checked for accessibility, as the message sender is not known in the context of this kind of method call.


 The complete list of reserved function names that do not start with the ``wooper_`` prefix is:

- ``get_class_name``
- ``get_superclasses``
- ``executeRequest``
- ``executeOneway``
- ``delete_any_instance_referenced_in``
- ``is_wooper_debug``

They are reserved for all arities.

Note that functions which must be defined by the class developer are unconditionally exported by the WOOPER header, so that a compile-time error is issued whenever at least one of them is not defined. -->
</div>
<div class="section" id="method-invocation">
<h4><a class="toc-backref" href="#id84">Method Invocation</a></h4>
<p>Let's suppose that the <tt class="docutils literal">MyCat</tt> variable designates an instance of <tt class="docutils literal">class_Cat</tt>. Then this <tt class="docutils literal">MyCat</tt> reference is actually just the PID of the Erlang process hosting this instance.</p>
<p>All member methods (regardless of whether they are defined directly by the actual class or inherited) are to be called from outside this class thanks to a proper Erlang message, sent to the PID of the targeted instance.</p>
<p>When the method is expected to return a result (i.e. when it is a request method), the caller must specify in the corresponding message its own PID, so that the instance knows to whom the result should be sent.</p>
<p>Therefore the <tt class="docutils literal">self()</tt> parameter in the call tuples below corresponds to the PID <em>of the caller</em>, while <tt class="docutils literal">MyCat</tt> is bound to the PID <em>of the target instance</em>.</p>
<p>The three methods previously discussed would indeed be called that way:</p>
<pre class="code erlang literal-block">
<span class="comment">% Calling the canEat request of our cat instance:
</span><span class="name variable">MyCat</span> <span class="operator">!</span> <span class="punctuation">{</span><span class="name">canEat</span><span class="punctuation">,</span><span class="name">soup</span><span class="punctuation">,</span><span class="name">self</span><span class="punctuation">()},</span>
<span class="keyword">receive</span>
        <span class="punctuation">{</span><span class="name">wooper_result</span><span class="punctuation">,</span><span class="name">true</span><span class="punctuation">}</span> <span class="operator">-&gt;</span>
              <span class="name namespace">io</span><span class="punctuation">:</span><span class="name function">format</span><span class="punctuation">(</span> <span class="literal string">&quot;This cat likes soup!!!&quot;</span> <span class="punctuation">);</span>

        <span class="punctuation">{</span><span class="name">wooper_result</span><span class="punctuation">,</span><span class="name">false</span><span class="punctuation">}</span> <span class="operator">-&gt;</span>
              <span class="name namespace">io</span><span class="punctuation">:</span><span class="name function">format</span><span class="punctuation">(</span> <span class="literal string">&quot;This cat does not seem omnivorous.&quot;</span> <span class="punctuation">)</span>
<span class="keyword">end</span><span class="punctuation">,</span>

<span class="comment">% A parameter-less request:
</span><span class="name variable">MyCat</span> <span class="operator">!</span> <span class="punctuation">{</span><span class="name">getWhiskersColor</span><span class="punctuation">,[],</span><span class="name">self</span><span class="punctuation">()},</span>
<span class="keyword">receive</span>
        <span class="punctuation">{</span><span class="name">wooper_result</span><span class="punctuation">,</span><span class="name">white</span><span class="punctuation">}</span> <span class="operator">-&gt;</span>
              <span class="name namespace">io</span><span class="punctuation">:</span><span class="name function">format</span><span class="punctuation">(</span> <span class="literal string">&quot;This cat has normal whiskers.&quot;</span> <span class="punctuation">);</span>

        <span class="punctuation">{</span><span class="name">wooper_result</span><span class="punctuation">,</span><span class="name">blue</span><span class="punctuation">}</span> <span class="operator">-&gt;</span>
              <span class="name namespace">io</span><span class="punctuation">:</span><span class="name function">format</span><span class="punctuation">(</span> <span class="literal string">&quot;What a weird cat...&quot;</span> <span class="punctuation">)</span>
<span class="keyword">end</span><span class="punctuation">,</span>

<span class="comment">% A parameter-less oneway:
</span><span class="name variable">MyCat</span> <span class="operator">!</span> <span class="name">declareBirthday</span><span class="punctuation">.</span>
</pre>
</div>
<div class="section" id="method-name">
<h4><a class="toc-backref" href="#id85">Method Name</a></h4>
<p>Methods are designated by their name (as an atom), as specified in the <tt class="docutils literal">wooper_method_export</tt> define of the class in the inheritance tree that defines them.</p>
<p>The method name is always the first information given in the method call tuple.</p>
</div>
<div class="section" id="method-parameters">
<h4><a class="toc-backref" href="#id86">Method Parameters</a></h4>
<p>All methods are free to change the state of their instance and possibly trigger any side-effect (ex: sending a message, writing a file, etc.).</p>
<p>As detailed below, there are two kinds of methods:</p>
<ul class="simple">
<li><em>requests</em> methods: they shall return a result to the caller (obviously they need to know it, i.e. the caller has to specify its PID)</li>
<li><em>oneway</em> methods: no specific result are expected from them (hence no caller PID is to be specified)</li>
</ul>
<p>Both can take any number of parameters, including none. As always, the <strong>marshalling</strong> of these parameters and, if relevant, of any returned value is performed automatically by Erlang.</p>
<p>Parameters are to be specified in a (possibly empty) list, as second element of the call tuple.</p>
<p>If only a single, non-list, parameter is needed, the list can be omitted, and the parameter can be directly specified: <tt class="docutils literal">Alfred ! {setAge,31}.</tt> works just as well as <tt class="docutils literal">Alfred ! <span class="pre">{setAge,[31]}.</span></tt>.</p>
<div class="admonition note" id="single-method-parameter-is-a-list">
<p class="first admonition-title">Note</p>
<p>This cannot apply if the unique parameter is a list, as this would be ambiguous.</p>
<p>For example: <tt class="docutils literal">Foods = [meat,soup,croquette], MyCat ! {setFavoriteFoods,Foods}</tt> would result in a call to <tt class="docutils literal">setFavoriteFoods/4</tt>, i.e. a call to <tt class="docutils literal">setFavoriteFoods(State,meat,soup,croquette)</tt>, whereas the intent of the programmer is probably to call a <tt class="docutils literal">setFavoriteFoods/2</tt> method like <tt class="docutils literal">setFavoriteFoods(State,Foods) when is_list(Foods) <span class="pre">-&gt;</span> <span class="pre">[..]</span></tt>.</p>
<p class="last">The proper call would then be <tt class="docutils literal">MyCat ! <span class="pre">{setFavoriteFoods,[Foods]}</span></tt>, i.e. the parameter list should be used, and it would then contain only one element, the food list, whose content would therefore be doubly enclosed.</p>
</div>
</div>
<div class="section" id="two-kinds-of-methods">
<h4><a class="toc-backref" href="#id87">Two Kinds of Methods</a></h4>
<div class="section" id="request-methods">
<h5>Request Methods</h5>
<p>A <strong>request</strong> is a method that returns a result to the caller.</p>
<p>For an instance to be able to send an answer to a request triggered by a caller, of course that instance needs to know the caller PID.</p>
<p>Therefore requests have to specify, as the third element of the call tuple, an additional information: the PID to which the answer should be sent, which is almost always the caller (hence the <tt class="docutils literal">self()</tt> in the actual calls).</p>
<p>So these three potential information (request name, parameters, reference of the sender - i.e. an atom, usually a list, and a PID) are gathered in a triplet (a 3-tuple) sent as a message: <tt class="docutils literal"><span class="pre">{request_name,[Arg1,Arg2,..],self()}</span></tt>.</p>
<p>If only one parameter is to be sent, and if that parameter is not a list, then this can become <tt class="docutils literal"><span class="pre">{request_name,Arg,self()}</span></tt>.</p>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="name variable">MyCat</span> <span class="operator">!</span> <span class="punctuation">{</span><span class="name">getAge</span><span class="punctuation">,[],</span><span class="name">self</span><span class="punctuation">()}</span>
</pre>
<p>or:</p>
<pre class="code erlang literal-block">
<span class="name variable">Douglas</span> <span class="operator">!</span> <span class="punctuation">{</span><span class="name">askQuestionWithHint</span><span class="punctuation">,[{</span><span class="name">meaning_of</span><span class="punctuation">,</span><span class="literal string">&quot;Life&quot;</span><span class="punctuation">},{</span><span class="name">maybe</span><span class="punctuation">,</span><span class="literal number integer">42</span><span class="punctuation">}],</span><span class="name">self</span><span class="punctuation">()}</span>
</pre>
<p>or:</p>
<pre class="code erlang literal-block">
<span class="name variable">MyCalculator</span> <span class="operator">!</span> <span class="punctuation">{</span><span class="name">sum</span><span class="punctuation">,[[</span><span class="literal number integer">1</span><span class="punctuation">,</span><span class="literal number integer">2</span><span class="punctuation">,</span><span class="literal number integer">4</span><span class="punctuation">]],</span><span class="name">self</span><span class="punctuation">()}.</span>
</pre>
<p>The actual result <tt class="docutils literal">R</tt>, as determined by the method, is sent back as an Erlang message, which is a <tt class="docutils literal">{wooper_result,R}</tt> pair, to help the caller pattern-matching the WOOPER messages in its mailbox.</p>
<p><tt class="docutils literal">receive</tt> should then be used by the caller to retrieve the request result, like in the case of this example of a 2D point instance:</p>
<pre class="code erlang literal-block">
<span class="name variable">MyPoint</span> <span class="operator">!</span> <span class="punctuation">{</span><span class="name">getCoordinates</span><span class="punctuation">,[],</span><span class="name">self</span><span class="punctuation">()},</span>
<span class="keyword">receive</span>
       <span class="punctuation">{</span><span class="name">wooper_result</span><span class="punctuation">,[</span><span class="name variable">X</span><span class="punctuation">,</span><span class="name variable">Y</span><span class="punctuation">]}</span> <span class="operator">-&gt;</span>
               <span class="punctuation">[..]</span>
<span class="keyword">end</span><span class="punctuation">,</span>
<span class="punctuation">[..]</span>
</pre>
</div>
<div class="section" id="oneway-methods">
<h5>Oneway Methods</h5>
<p>A <strong>oneway</strong> is a method that does not return a result to the caller.</p>
<p>When calling oneway methods, the caller does not have to specify its PID, as no result is expected to be returned back to it.</p>
<p>If ever the caller sends by mistake its PID nevertheless, a warning is sent back to it, the atom <tt class="docutils literal">wooper_method_returns_void</tt>, instead of <tt class="docutils literal">{wooper_result,Result}</tt>.</p>
<p>The proper way of calling a oneway method is to send to it an Erlang message that is:</p>
<ul class="simple">
<li>either a pair, i.e. a 2-element tuple (therefore with no PID specified): <tt class="docutils literal"><span class="pre">{oneway_name,[Arg1,Arg2,..]}</span></tt> or <tt class="docutils literal">{oneway_name,Arg}</tt> if <tt class="docutils literal">Arg</tt> is not a list; for example: <tt class="docutils literal">MyPoint ! <span class="pre">{setCoordinates,[14,6]}</span></tt> or <tt class="docutils literal">MyCat ! {setAge,5}</tt></li>
<li>or, if the oneway does not take any parameter, just the atom <tt class="docutils literal">oneway_name</tt>. For example: <tt class="docutils literal">MyCat ! declareBirthday</tt></li>
</ul>
<p>No return should be expected (the called instance does not even know the PID of the caller), so no receive should be attempted on the caller side, unless wanting to wait until the end of time.</p>
<p>Due to the nature of oneways, if an error occurs instance-side during the call, the caller will never be notified of it.</p>
<p>However, to help the debugging, an error message is then logged (using <tt class="docutils literal">error_logger:error_msg</tt>) and the actual error message, the one that would be sent back to the caller if the method was a request, is given to <tt class="docutils literal">erlang:exit</tt> instead.</p>
</div>
</div>
<div class="section" id="method-results">
<h4><a class="toc-backref" href="#id88">Method Results</a></h4>
<div class="section" id="execution-success-wooper-result-actualresult">
<h5>Execution Success: <tt class="docutils literal">{wooper_result,ActualResult}</tt></h5>
<p>If the execution of a method succeeded, and if the method is a request, then <tt class="docutils literal">{wooper_result,ActualResult}</tt> will be sent back to the caller (precisely: to the process whose PID was specified in the call triplet).</p>
<p>Otherwise one of the following error messages will be emitted.</p>
</div>
<div class="section" id="execution-failures">
<h5>Execution Failures</h5>
<p>When the execution of a method fails, three main error results can be output (as a message for requests, as a log for oneways).</p>
<p>A summary could be:</p>
<table border="1" class="docutils">
<colgroup>
<col width="43%" />
<col width="35%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Error Result</th>
<th class="head">Interpretation</th>
<th class="head">Likely Guilty</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">wooper_method_not_found</tt></td>
<td>No such method exists in
the target class.</td>
<td>Caller</td>
</tr>
<tr><td><tt class="docutils literal">wooper_method_failed</tt></td>
<td>Method triggered a runtime
error (it has a bug).</td>
<td>Called instance</td>
</tr>
<tr><td><tt class="docutils literal">wooper_method_faulty_return</tt></td>
<td>Method does not respect
the WOOPER return
convention.</td>
<td>Called instance</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">More generally, failure detection may better be done through the use of (Erlang) links, either explicitly set (with <tt class="docutils literal">erlang:link/1</tt>) or, preferably (ex: to avoid race conditions), with a linked variation of the <tt class="docutils literal">new</tt> operator (ex: <tt class="docutils literal">new_link/n</tt>), discussed later in this document.</p>
</div>
<div class="section" id="wooper-method-not-found">
<h6><tt class="docutils literal">wooper_method_not_found</tt></h6>
<p>The corresponding error message is <tt class="docutils literal">{wooper_method_not_found, InstancePid, Classname, MethodName, MethodArity, ListOfActualParameters}</tt>.</p>
<p>For example <tt class="docutils literal">{wooper_method_not_found, &lt;0.30.0&gt;, class_Cat, layEggs, 2, <span class="pre">...}</span></tt>.</p>
<p>Note that <tt class="docutils literal">MethodArity</tt> includes the implied state parameter (that will be discussed later), i.e. here <tt class="docutils literal">layEggs/2</tt> might be defined as <tt class="docutils literal">layEggs(State,NumberOfNewEggs) <span class="pre">-&gt;</span> <span class="pre">[..]</span></tt>.</p>
<p>This error occurs whenever a called method could not be found in the whole inheritance graph of the target class. It means this method is not implemented, at least not with the deduced arity.</p>
<p>More precisely, when a message <tt class="docutils literal"><span class="pre">{method_name,[Arg1,Arg2,..,ArgN]...}</span></tt> (request or oneway) is received, <tt class="docutils literal">method_name/N+1</tt> has be to called: WOOPER tries to find <tt class="docutils literal"><span class="pre">method_name(State,Arg1,..,ArgN)</span></tt>, and the method name and arity must match.</p>
<p>If no method could be found, the <tt class="docutils literal">wooper_method_not_found</tt> atom is returned (if the method is a request, otherwise the error is logged), and the object state will not change, nor the instance will crash, as this error is deemed a caller-side one (i.e. the instance has a priori nothing to do with the error).</p>
</div>
<div class="section" id="wooper-method-failed">
<h6><tt class="docutils literal">wooper_method_failed</tt></h6>
<p>The corresponding error message is <tt class="docutils literal">{wooper_method_failed, InstancePid, Classname, MethodName, MethodArity, ListOfActualParameters, ErrorTerm}</tt>.</p>
<p>For example, <tt class="docutils literal">{wooper_method_failed, &lt;0.30.0&gt;, class_Cat, myCrashingMethod, 1, [], {{badmatch,create_bug}, <span class="pre">[..]]}</span></tt>.</p>
<p>If the exit message sent by the method specifies a PID, it is prepended to ErrorTerm.</p>
<p>Such a method error means there is a runtime failure, it is generally deemed a instance-side issue (the caller should not be responsible for it, unless it sent incorrect parameters), thus the instance process logs that error, sends an error term to the caller (if and only if it is a request), and then exits with the same error term.</p>
</div>
<div class="section" id="wooper-method-faulty-return">
<h6><tt class="docutils literal">wooper_method_faulty_return</tt></h6>
<p>The corresponding error message is <tt class="docutils literal">{wooper_method_faulty_return, InstancePid, Classname, MethodName, MethodArity, ListOfActualParameters, ActualReturn}</tt>.</p>
<p>For example, <tt class="docutils literal">{wooper_method_faulty_return, &lt;0.30.0&gt;, class_Cat, myFaultyMethod, 1, [], <span class="pre">[{{state_holder,..]}</span></tt>.</p>
<p>This error occurs only when being in debug mode.</p>
<p>The main reason for this to happen is when debug mode is set and when a method implementation did not respect the expected method return convention (neither the <tt class="docutils literal">wooper_return_state_result</tt> macro nor the <tt class="docutils literal">wooper_return_state_only</tt> one was used in this method clause).</p>
<p>It means the method is not implemented correctly (it has a bug), or that it was not (re)compiled with the proper debug mode, i.e. the one the caller was compiled with.</p>
<p>This is an instance-side failure (the caller has no responsibility for that), thus the instance process logs that error, sends an error term to the caller (if and only if it is a request), and then exits with the same error term.</p>
</div>
<div class="section" id="caller-side-error-management">
<h6>Caller-Side Error Management</h6>
<p>As we can see, errors can be better discriminated if needed, on the caller side.
Therefore one could make use of that information, as in:</p>
<pre class="code erlang literal-block">
<span class="name variable">MyPoint</span> <span class="operator">!</span> <span class="punctuation">{</span><span class="name">getCoordinates</span><span class="punctuation">,[],</span><span class="name">self</span><span class="punctuation">()},</span>
<span class="keyword">receive</span>
        <span class="punctuation">{</span><span class="name">wooper_result</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="name variable">X</span><span class="punctuation">,</span><span class="name variable">Y</span><span class="punctuation">]</span> <span class="punctuation">}</span> <span class="operator">-&gt;</span>
              <span class="punctuation">[..];</span>
        <span class="punctuation">{</span><span class="name">wooper_method_not_found</span><span class="punctuation">,</span> <span class="name variable">Pid</span><span class="punctuation">,</span> <span class="name variable">Class</span><span class="punctuation">,</span> <span class="name variable">Method</span><span class="punctuation">,</span> <span class="name variable">Arity</span><span class="punctuation">,</span> <span class="name variable">Params</span><span class="punctuation">}</span> <span class="operator">-&gt;</span>
              <span class="punctuation">[..];</span>
        <span class="punctuation">{</span><span class="name">wooper_method_failed</span><span class="punctuation">,</span> <span class="name variable">Pid</span><span class="punctuation">,</span> <span class="name variable">Class</span><span class="punctuation">,</span> <span class="name variable">Method</span><span class="punctuation">,</span> <span class="name variable">Arity</span><span class="punctuation">,</span> <span class="name variable">Params</span><span class="punctuation">,</span> <span class="name variable">ErrorTerm</span><span class="punctuation">}</span> <span class="operator">-&gt;</span>
              <span class="punctuation">[..];</span>
        <span class="comment">% Error term can be a tuple {Pid,Error} as well, depending on the exit:
</span>        <span class="punctuation">{</span><span class="name">wooper_method_failed</span><span class="punctuation">,</span> <span class="name variable">Pid</span><span class="punctuation">,</span> <span class="name variable">Class</span><span class="punctuation">,</span> <span class="name variable">Method</span><span class="punctuation">,</span> <span class="name variable">Arity</span><span class="punctuation">,</span> <span class="name variable">Params</span><span class="punctuation">,</span> <span class="punctuation">{</span><span class="name variable">Pid</span><span class="punctuation">,</span><span class="name variable">Error</span><span class="punctuation">}}</span> <span class="operator">-&gt;</span>
              <span class="punctuation">[..];</span>
        <span class="punctuation">{</span><span class="name">wooper_method_faulty_return</span><span class="punctuation">,</span> <span class="name variable">Pid</span><span class="punctuation">,</span> <span class="name variable">Class</span><span class="punctuation">,</span> <span class="name variable">Method</span><span class="punctuation">,</span> <span class="name variable">Arity</span><span class="punctuation">,</span> <span class="name variable">Params</span><span class="punctuation">,</span> <span class="name variable">UnexpectedTerm</span><span class="punctuation">}</span> <span class="operator">-&gt;</span>
              <span class="punctuation">[..];</span>
        <span class="name">wooper_method_returns_void</span> <span class="operator">-&gt;</span>
              <span class="punctuation">[..];</span>
        <span class="name variable">OtherError</span> <span class="operator">-&gt;</span>
              <span class="comment">% Should never happen:
</span>              <span class="punctuation">[..]</span>
<span class="keyword">end</span><span class="punctuation">.</span>
</pre>
<p>However defensive development is not really favoured in Erlang, one may let the caller crash on unexpected return instead. Therefore generally one may rely simply on matching the message sent in case of success <a class="footnote-reference" href="#id12" id="id11">[5]</a>:</p>
<pre class="code erlang literal-block">
<span class="name variable">MyPoint</span> <span class="operator">!</span> <span class="punctuation">{</span><span class="name">getCoordinates</span><span class="punctuation">,[],</span><span class="name">self</span><span class="punctuation">()},</span>
<span class="keyword">receive</span>
        <span class="punctuation">{</span><span class="name">wooper_result</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="name variable">X</span><span class="punctuation">,</span><span class="name variable">Y</span><span class="punctuation">]</span> <span class="punctuation">}</span> <span class="operator">-&gt;</span>
              <span class="punctuation">[..]</span>
<span class="keyword">end</span><span class="punctuation">,</span>
<span class="punctuation">[..]</span>
</pre>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[5]</a></td><td>In which case, should a failure happen, the method call will become blocking.</td></tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section" id="method-definition">
<h4><a class="toc-backref" href="#id89">Method Definition</a></h4>
<p>Here we reverse the point of view: instead of <strong>calling</strong> a method, we are in the process of <strong>implementing</strong> a callable one.</p>
<p>A method signature has always for first parameter the state of the instance, for example: <tt class="docutils literal">getAge(State) <span class="pre">-&gt;</span> <span class="pre">[..]</span></tt>, or <tt class="docutils literal">getCoordinate(State,Index) <span class="pre">-&gt;</span> <span class="pre">[..]</span></tt>.</p>
<p>For the sake of clarity, this variable should preferably always be named <tt class="docutils literal">State</tt>.</p>
<p>A method must always return at least the newer instance state, even if the state did not change.</p>
<p>In this case the initial state parameter is directly returned, as is, like in:</p>
<pre class="code erlang literal-block">
<span class="name function">getWhiskerColor</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
      <span class="operator">?</span><span class="name">wooper_return_state_result</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="operator">?</span><span class="name">getAttr</span><span class="punctuation">(</span><span class="name">whisker_color</span><span class="punctuation">)</span> <span class="punctuation">).</span>
</pre>
<p>State is unchanged here.</p>
<p>Note that when a method &quot;returns&quot; the state of the instance, it returns it to the (local, process-wise) private WOOPER-based main loop of that instance: in other words, the state variable is <em>never</em> exported/sent/visible outside of its process (unless of course a developer writes a specific method for that).</p>
<p>Encapsulation is ensured, as the instance is the only process able to access its own state. On method ending, the instance then just loops again, with its updated state: that new state will be the base one for the next call, and so on.</p>
<p>One should therefore see each WOOPER instance as primarily a process executing a main loop that keeps the current stat of that instance:</p>
<ul class="simple">
<li>it is waiting idle for any incoming (WOOPER) message</li>
<li>when such a message is received, based on the actual class of the instance and on the method name specified in the call, the appropriate function defined in the appropriate module is selected by WOOPER, taking into account the inheritance graph (actually a direct per-class mapping, somewhat akin to the C++ virtual table, was already determined at start-up, for better performances)</li>
<li>then this function is called with the appropriate parameters (those of the call, in addition to the internally kept current state)</li>
<li>if the method is a request, the specified result is sent back to the caller</li>
<li>then the instance loops again, on a state possibly updated by this method call</li>
</ul>
<p>Thus the caller will only receive the <strong>result</strong> of a method, if it is a request. Otherwise, i.e. with oneways, nothing is sent back (nothing can be, anyway).</p>
<p>More precisely, depending on its returning a specific result, the method signature will correspond either to the one of a request or of a oneway, and will use in its body, respectively, either the <tt class="docutils literal">wooper_return_state_result</tt> or the <tt class="docutils literal">wooper_return_state_only</tt> macro to ensure that a state <em>and</em> a result are returned, or just a state.</p>
<p>A good practise is to add a comment to each method definition, and to specify whether it is a request or a oneway, if it is a <tt class="docutils literal">const</tt> method, etc. For example, the previous method could be best written as:</p>
<pre class="code erlang literal-block">
<span class="comment">% Returns the current color of the whiskers of that cat instance.
% (const request)
</span><span class="name function">getWhiskerColor</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
       <span class="operator">?</span><span class="name">wooper_return_state_result</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span> <span class="operator">?</span><span class="name">getAttr</span><span class="punctuation">(</span><span class="name">whisker_color</span><span class="punctuation">)).</span>
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When a constructor or a method determines that a fatal error should be raised (for example because it cannot find a required registered process), it should use <tt class="docutils literal">throw</tt>, like in: <tt class="docutils literal"><span class="pre">throw({invalid_value,V})</span></tt>. Using <tt class="docutils literal">exit</tt> is supported but not recommended.</p>
</div>
<div class="section" id="for-requests">
<h5>For Requests</h5>
<p>Requests will use <tt class="docutils literal"><span class="pre">?wooper_return_state_result(NewState,Result)</span></tt>: the new state will be kept by the instance, whereas the result will be sent to the caller. Hence <tt class="docutils literal">wooper_return_state_result</tt> means that the method returns a state <strong>and</strong> a result.</p>
<p>For example a const request will return an unchanged state, and thus will be just useful for its result (and possible side-effects):</p>
<pre class="code erlang literal-block">
<span class="name function">getAge</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
       <span class="operator">?</span><span class="name">wooper_return_state_result</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="operator">?</span><span class="name">getAttr</span><span class="punctuation">(</span><span class="name">age</span><span class="punctuation">)).</span>
</pre>
<p>All methods are of course given the parameters specified at their call.</p>
<p>For example, we can declare:</p>
<pre class="code erlang literal-block">
<span class="name function">giveBirth</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name variable">NumberOfMaleChildren</span><span class="punctuation">,</span><span class="name variable">NumberOfFemaleChildren</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
       <span class="punctuation">[..]</span>
</pre>
<p>And then we may call it, in the case of a cat having 2 male kitten and 3 female ones, with:</p>
<pre class="code erlang literal-block">
<span class="name variable">MyCat</span> <span class="operator">!</span> <span class="punctuation">{</span><span class="name">giveBirth</span><span class="punctuation">,[</span><span class="literal number integer">2</span><span class="punctuation">,</span><span class="literal number integer">3</span><span class="punctuation">],</span><span class="name">self</span><span class="punctuation">()}.</span>
</pre>
<p>Requests can access to one more information than oneways: the PID of the caller that sent the request. As WOOPER takes care automatically of sending back the result to the caller, having the request know explicitly the caller is usually not useful, thus the caller PID does not appear explicitly in request signatures, among the actual parameters.</p>
<p>However WOOPER keeps track of this information, which remains available to requests.</p>
<p>The caller PID can indeed be retrieved from a request body by using the <tt class="docutils literal">getSender</tt> macro, which is automatically managed by WOOPER:</p>
<pre class="code erlang literal-block">
<span class="name function">giveBirth</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name variable">NumberOfMaleChildren</span><span class="punctuation">,</span><span class="name variable">NumberOfFemaleChildren</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
      <span class="name variable">CallerPID</span> <span class="operator">=</span> <span class="operator">?</span><span class="name">getSender</span><span class="punctuation">(),</span>
      <span class="punctuation">[..]</span>
</pre>
<p>Thus a request has natively access to its caller PID, i.e. with no need to specify it in the parameters as well as in the third element of the call tuple; so, instead of having to define:</p>
<pre class="code erlang literal-block">
<span class="name variable">MyCat</span> <span class="operator">!</span> <span class="punctuation">{</span><span class="name">giveBirth</span><span class="punctuation">,[</span><span class="literal number integer">2</span><span class="punctuation">,</span><span class="literal number integer">3</span><span class="punctuation">,</span><span class="name">self</span><span class="punctuation">()],</span><span class="name">self</span><span class="punctuation">()}</span>
</pre>
<p>one can rely on only:</p>
<pre class="code erlang literal-block">
<span class="name variable">MyCat</span> <span class="operator">!</span> <span class="punctuation">{</span><span class="name">giveBirth</span><span class="punctuation">,[</span><span class="literal number integer">2</span><span class="punctuation">,</span><span class="literal number integer">3</span><span class="punctuation">],</span><span class="name">self</span><span class="punctuation">()}</span>
</pre>
<p>while still letting the possibility for the called request (here <tt class="docutils literal">giveBirth/3</tt>, for a state and two parameters) to access the caller PID thanks to the <tt class="docutils literal">getSender</tt> macro, and maybe store it for a later use or do anything appropriate with it.</p>
<p>Note that having to handle explicitly the caller PID is rather uncommon, as WOOPER takes care automatically of the sending of the result back to the caller.</p>
<p>The <tt class="docutils literal">getSender</tt> macro should only be used for requests, as of course the sender PID has no meaning in the case of oneways.</p>
<p>If that macro is called nevertheless from a oneway, then it returns the atom <tt class="docutils literal">undefined</tt>.</p>
</div>
<div class="section" id="for-oneways">
<h5>For Oneways</h5>
<p>Oneway will rely on the <tt class="docutils literal"><span class="pre">?wooper_return_state_only(NewState)</span></tt> macro: the instance state will be updated, but no result will be returned to the caller, which is not even known.</p>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="name function">setAge</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name variable">NewAge</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
      <span class="operator">?</span><span class="name">wooper_return_state_only</span><span class="punctuation">(</span> <span class="name">setAttribute</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name">age</span><span class="punctuation">,</span><span class="name variable">NewAge</span><span class="punctuation">)</span> <span class="punctuation">).</span>
</pre>
<p>This oneway can be called that way:</p>
<pre class="code erlang literal-block">
<span class="name variable">MyCat</span> <span class="operator">!</span> <span class="punctuation">{</span><span class="name">setAge</span><span class="punctuation">,</span><span class="literal number integer">4</span><span class="punctuation">}.</span>
<span class="comment">% No result to expect.</span>
</pre>
<p>Oneways may also be <tt class="docutils literal">const</tt>, i.e. leave the state unchanged, only being called for side-effects, for example:</p>
<pre class="code erlang literal-block">
<span class="name function">displayAge</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
      <span class="name namespace">io</span><span class="punctuation">:</span><span class="name function">format</span><span class="punctuation">(</span><span class="literal string">&quot;My age is </span><span class="literal string interpol">~B~n</span><span class="literal string">.&quot;</span><span class="punctuation">,[</span> <span class="operator">?</span><span class="name">getAttr</span><span class="punctuation">(</span><span class="name">age</span><span class="punctuation">)</span> <span class="punctuation">]),</span>
      <span class="operator">?</span><span class="name">wooper_return_state_only</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">).</span>
</pre>
</div>
<div class="section" id="usefulness-of-these-two-return-macros">
<h5>Usefulness Of These Two Return Macros</h5>
<p>The definition of the <tt class="docutils literal">wooper_return_state_result</tt> and <tt class="docutils literal">wooper_return_state_only</tt> macros is actually quite simple; they are just here to structure the method implementations (helping the method developer not mixing updated states and results), and to help ensuring, in debug mode, that methods return well-formed information: an atom is then prepended to the returned tuple and WOOPER matches it during post-invocation, before handling the return, for an increased safety.</p>
<p>For example, in debug mode, <tt class="docutils literal"><span class="pre">?wooper_return_state_result(AState,AResult)</span></tt> will simply translate into <tt class="docutils literal">{wooper_result,AState,AResult}</tt>, and when the execution of the method is over, the WOOPER main loop of this instance will attempt to match the method returned value with that triplet.</p>
<p>Similarly, <tt class="docutils literal"><span class="pre">?wooper_return_state_only(AState)</span></tt> will translate into <tt class="docutils literal">{wooper_result,AState}</tt>.</p>
<p>If not in debug mode, then the <tt class="docutils literal">wooper_result</tt> atom will not even be added in the returned tuples; for example <tt class="docutils literal"><span class="pre">?wooper_return_state_result(AState,AResult)</span></tt> will just be <tt class="docutils literal">{AState,AResult}</tt>.</p>
<p>Performances should increase a bit, at the expense of a less safe checking of the values returned by methods.</p>
<p>The two <tt class="docutils literal">wooper_return_state_*</tt> macros have been introduced so that the unwary developer does not forget that his requests are not arbitrary functions, that they should not only return a result but also a state, and that the order is always: first the state, then the result, not the other way round.</p>
</div>
<div class="section" id="type-specifications">
<h5>Type Specifications</h5>
<p>Although doing so is optional, WOOPER strongly recommends declaring type specifications as well (and provides suitable constructs for that), like in:</p>
<pre class="code erlang literal-block">
<span class="comment">% Returns the current color of the whiskers of that cat instance.
% (const request)
</span><span class="punctuation">-</span><span class="name entity">spec</span> <span class="name">getWhiskerColor</span><span class="punctuation">(</span><span class="name namespace">wooper</span><span class="punctuation">:</span><span class="name function">state</span><span class="punctuation">())</span> <span class="operator">-&gt;</span> <span class="name">request_return</span><span class="punctuation">(</span><span class="name">color</span><span class="punctuation">()).</span>
<span class="name function">getWhiskerColor</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
        <span class="operator">?</span><span class="name">wooper_return_state_result</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span> <span class="operator">?</span><span class="name">getAttr</span><span class="punctuation">(</span><span class="name">whisker_color</span><span class="punctuation">)).</span>
</pre>
<p>(of course the developer is responsible for the definition of the <tt class="docutils literal">color()</tt> type here)</p>
<p>Similarly, the aforementioned <tt class="docutils literal">declareBirthday/1</tt> oneway could be defined as:</p>
<pre class="code erlang literal-block">
<span class="comment">% Declares the birthday of this creature: increments its age.
% (oneway)
</span><span class="punctuation">-</span><span class="name entity">spec</span> <span class="name">declareBirthday</span><span class="punctuation">(</span><span class="name namespace">wooper</span><span class="punctuation">:</span><span class="name function">state</span><span class="punctuation">())</span> <span class="operator">-&gt;</span> <span class="name">oneway_return</span><span class="punctuation">().</span>
<span class="name function">declareBirthday</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
       <span class="name variable">AgedState</span> <span class="operator">=</span> <span class="name">setAttribute</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span> <span class="name">age</span><span class="punctuation">,</span> <span class="operator">?</span><span class="name">getAttr</span><span class="punctuation">(</span><span class="name">age</span><span class="punctuation">)</span><span class="operator">+</span><span class="literal number integer">1</span><span class="punctuation">),</span>
       <span class="operator">?</span><span class="name">wooper_return_state_ony</span><span class="punctuation">(</span><span class="name variable">AgedState</span><span class="punctuation">).</span>
</pre>
</div>
</div>
<div class="section" id="self-invocation-calling-a-method-from-the-instance-itself">
<h4><a class="toc-backref" href="#id90">Self-Invocation: Calling a Method From The Instance Itself</a></h4>
<p>When implementing a method of a class, one may want to call other methods <strong>of that same class</strong> (have they been overridden or not).</p>
<p>For example, when developing a <tt class="docutils literal">declareBirthday/1</tt> oneway of <tt class="docutils literal">class_Mammal</tt> (which, among other things, is expected to increment the mammal age), you may want to perform a call to the <tt class="docutils literal">setAge/2</tt> oneway (possibly introduced by an ancestor class like <tt class="docutils literal">class_Creature</tt>, or possibly overridden directly in <tt class="docutils literal">class_Mammal</tt>) on the current instance.</p>
<p>One could refer to this method respectively as a function exported by that ancestor (ex: called as <tt class="docutils literal"><span class="pre">class_Creature:setAge(...)</span></tt>) or that is local to the current module (a <tt class="docutils literal"><span class="pre">setAge(...)</span></tt> call designating then <tt class="docutils literal">class_Mammal:setAge/2</tt>).</p>
<p>However, in the future, child classes of <tt class="docutils literal">class_Mammal</tt> may be introduced (ex: <tt class="docutils literal">class_Cat</tt>), and they might define their own version of <tt class="docutils literal">setAge/2</tt>.</p>
<p>Instead of hardcoding which version of that method shall be called (like in the two previous cases, which establish statically the intended version to call), a developer may desire, if not expect, that, for a cat or for any specialised version thereof, <tt class="docutils literal">declareBirthday/1</tt> calls automatically the &quot;right&quot; <tt class="docutils literal">setAge/2</tt> method (i.e. the lastly overridden one in the inheritance graph). Possibly any <tt class="docutils literal">class_Cat:setAge/2</tt> - not the version of <tt class="docutils literal">class_Creature</tt> or <tt class="docutils literal">class_Mammal</tt>.</p>
<p>Such an inheritance-aware call could be easily triggered asynchronously: a classical message-based method call directly addressed by an instance to itself could be used, like in <tt class="docutils literal"><span class="pre">self()!{setAge,10}</span></tt>, and (thanks to WOOPER) this would lead to executing the &quot;right&quot; version of that method.</p>
<p>If this approach may be useful when not directly needing from the method the result of the call and/or not needing to have it executed at once, in the general case one wants to have that possibly overridden method be executed <em>directly</em>, synchronously, and to obtain immediately the corresponding updated state and, if relevant, the associated output result.</p>
<p>Then one should call the WOOPER-defined <tt class="docutils literal"><span class="pre">executeRequest/{2,3}</span></tt> or <tt class="docutils literal"><span class="pre">executeOneway/{2,3}</span></tt> functions (or any variation thereof), depending on the type of the method to call.</p>
<p>These two helper functions behave quite similarly to the actual method calls that are based on the operator <tt class="docutils literal">!</tt>, except that no target instance has to be specified (since it is by definition a call made by an instance to itself) and that no message exchange at all is involved: the method look-up is just performed through the inheritance hierarchy, the correct method is called with the specified parameters and the result is then directly returned.</p>
<p>More precisely, <strong>executeRequest</strong> is <tt class="docutils literal">executeRequest/2</tt> or <tt class="docutils literal">executeRequest/3</tt>, its parameters being the current state, the name of the request method, and, if needed, the parameters of the called request, either as a list or as a standalone one.</p>
<p><tt class="docutils literal">executeRequest</tt> returns a pair made of the new state and of the result.</p>
<p>For example, for a request taking more than one parameter, or one list parameter:</p>
<pre class="code erlang literal-block">
<span class="punctuation">{</span><span class="name variable">NewState</span><span class="punctuation">,</span><span class="name variable">Result</span><span class="punctuation">}</span> <span class="operator">=</span> <span class="name">executeRequest</span><span class="punctuation">(</span><span class="name variable">CurrentState</span><span class="punctuation">,</span> <span class="name">myRequestName</span><span class="punctuation">,</span>
                                                                       <span class="punctuation">[</span><span class="literal string">&quot;hello&quot;</span><span class="punctuation">,</span> <span class="literal number integer">42</span><span class="punctuation">])</span>
</pre>
<p>For a request taking exactly one, non-list, parameter:</p>
<pre class="code erlang literal-block">
<span class="punctuation">{</span><span class="name variable">NewState</span><span class="punctuation">,</span><span class="name variable">NewCounter</span><span class="punctuation">}</span> <span class="operator">=</span> <span class="name">executeRequest</span><span class="punctuation">(</span><span class="name variable">CurrentState</span><span class="punctuation">,</span>
                                                                 <span class="name">addToCurrentCounter</span><span class="punctuation">,</span> <span class="literal number integer">78</span><span class="punctuation">)</span>
</pre>
<p>For a request taking no parameter:</p>
<pre class="code erlang literal-block">
<span class="punctuation">{</span><span class="name variable">NewState</span><span class="punctuation">,</span><span class="name variable">Sentence</span><span class="punctuation">}</span> <span class="operator">=</span> <span class="name">executeRequest</span><span class="punctuation">(</span><span class="name variable">CurrentState</span><span class="punctuation">,</span> <span class="name">getLastSentence</span><span class="punctuation">)</span>
</pre>
<p>Regarding now <strong>executeOneway</strong>, it is either <tt class="docutils literal">executeOneway/2</tt> or <tt class="docutils literal">executeOneway/3</tt>, depending on whether the oneway takes parameters. If yes, they can be specified as a list (if there are more than one) or, as always, as a standalone non-list parameter.</p>
<p><tt class="docutils literal">executeOneway</tt> returns the new state.</p>
<p>For example, a oneway taking more than one parameter, or one list parameter:</p>
<pre class="code erlang literal-block">
<span class="name variable">NewState</span> <span class="operator">=</span> <span class="name">executeOneway</span><span class="punctuation">(</span><span class="name variable">CurrentState</span><span class="punctuation">,</span><span class="name">say</span><span class="punctuation">,[</span> <span class="literal string">&quot;hello&quot;</span><span class="punctuation">,</span> <span class="literal number integer">42</span> <span class="punctuation">])</span>
</pre>
<p>For a oneway taking exactly one (non-list) parameter:</p>
<pre class="code erlang literal-block">
<span class="name variable">NewState</span> <span class="operator">=</span> <span class="name">executeOneway</span><span class="punctuation">(</span><span class="name variable">CurrentState</span><span class="punctuation">,</span><span class="name">setAge</span><span class="punctuation">,</span><span class="literal number integer">78</span><span class="punctuation">)</span>
</pre>
<p>For a oneway taking no parameter:</p>
<pre class="code erlang literal-block">
<span class="name variable">NewState</span> <span class="operator">=</span> <span class="name">executeOneway</span><span class="punctuation">(</span><span class="name variable">CurrentState</span><span class="punctuation">,</span><span class="name">declareBirthday</span><span class="punctuation">)</span>
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As discussed previously, there are caller-side errors that are not expected to crash the instance. If such a call is performed directly from that instance (i.e. with one of the <tt class="docutils literal">execute*</tt> constructs), then two errors will be output: the first, non-fatal for the instance, due to the method call, then the second, fatal for the instance, due to the failure of the <tt class="docutils literal">execute*</tt> call. This is the expected behaviour, as here the instance plays both roles, the caller and the callee.</p>
</div>
<p>Finally, one can specify <strong>explicitly</strong> the class (of course belonging to the inheritance graph of that class) defining the version of the method that one wants to execute, bypassing the inheritance-aware overriding system.</p>
<p>For example, a method needing to call <tt class="docutils literal">setAge/2</tt> from its body would be expected to use something like: <tt class="docutils literal">AgeState = executeOneway(State,setAge,NewAge)</tt>.</p>
<p>If <tt class="docutils literal">class_Cat</tt> overrode <tt class="docutils literal">setAge/2</tt>, any cat instance would then call the overridden <tt class="docutils literal">class_Cat:setAge</tt> method instead of the original <tt class="docutils literal">class_Creature:setAge</tt>.</p>
<p>What if our specific method of <tt class="docutils literal">class_Cat</tt> wanted, for any reason, to call the <tt class="docutils literal">class_Creature</tt> version, now shadowed by an overridden version of it? In this case a <tt class="docutils literal">execute*With</tt> function should be used.</p>
<p>These functions, which are <tt class="docutils literal"><span class="pre">executeRequestWith/{3,4}</span></tt> and <tt class="docutils literal"><span class="pre">executeOnewayWith/{3,4}</span></tt>, behave exactly as the previous <tt class="docutils literal">execute*</tt> functions, except that they take an additional parameter (to be specified just after the state) that is the name of the mother class (direct or not) having defined the version of the method that we want to execute.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This mother class does not have to have specifically defined or overridden that method: this method will just be called in the context of that class, as if it was an instance of the mother class rather than one of the actual child class.</p>
</div>
<p>In our example, we should thus use simply:</p>
<pre class="code erlang literal-block">
<span class="name variable">AgeState</span> <span class="operator">=</span> <span class="name">executeOnewayWith</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name">class_Creature</span><span class="punctuation">,</span><span class="name">setAge</span><span class="punctuation">,</span><span class="name variable">NewAge</span><span class="punctuation">)</span>
</pre>
<p>in order to call the <tt class="docutils literal">class_Creature</tt> version of the <tt class="docutils literal">setAge/2</tt> oneway.</p>
</div>
<div class="section" id="static-methods">
<h4><a class="toc-backref" href="#id91">Static Methods</a></h4>
<p>Static methods, as opposed to member methods, do not target specifically an instance, they are defined at the class level.</p>
<p>They thus do not operate on PID, they are just to be called thanks to their module name, exactly as any exported standard function.</p>
<!-- comment Static methods are to be listed by the class developer thanks to the ``get_static_methods/0`` function, which must return a list whose elements are pairs, whose first part is the name (atom) of the static method, the second part being the arity of the static method. -->
<!-- comment For example: -->
<!-- comment  % Determines what are the static methods of this class (if any): -->
<!-- comment  get_static_methods() -> -->
<!-- comment      [ {get_default_whisker_color,0}, {compute_mew_frequency,2} ]. -->
<p>Static methods are to be listed by the class developer thanks to the <tt class="docutils literal">wooper_static_method_export</tt> define, like in:</p>
<pre class="code erlang literal-block">
<span class="punctuation">-</span><span class="name entity">define</span><span class="punctuation">(</span> <span class="name">wooper_static_method_export</span><span class="punctuation">,</span> <span class="name">get_default_whisker_color</span><span class="operator">/</span><span class="literal number integer">0</span><span class="punctuation">,</span>
                 <span class="name">determine_croquette_appeal</span><span class="operator">/</span><span class="literal number integer">1</span><span class="punctuation">,</span> <span class="name">foo_bar</span><span class="operator">/</span><span class="literal number integer">1</span> <span class="punctuation">).</span>
</pre>
<p>The static methods are automatically exported by WOOPER, so that they can be readily called from any context, as in:</p>
<pre class="code erlang literal-block">
<span class="name variable">PossibleColor</span> <span class="operator">=</span> <span class="name namespace">class_Cat</span><span class="punctuation">:</span><span class="name function">get_default_whisker_color</span><span class="punctuation">(),</span>
<span class="punctuation">[..]</span>
</pre>
<!-- comment Hence static methods can be called from anywhere, no qualifier like public, protected or private apply to them. -->
<p></p>
</div>
</div>
<div class="section" id="id13">
<span id="state-management"></span><h3><a class="toc-backref" href="#id92">State Management</a></h3>
<div class="section" id="principles">
<h4><a class="toc-backref" href="#id93">Principles</a></h4>
<p>We are discussing here about how an instance is to manage its inner state.</p>
<p>Its state is only directly accessible from inside the instance, i.e. from the body of its methods, whether they are inherited or not: the state of an instance is <strong>private</strong> (local to its process), and the outside can <em>only</em> access it through the methods defined by its class.</p>
<p>The state of an instance (corresponding to the one that is given by WOOPER as first parameter of all its methods, thanks to a variable conventionally named <tt class="docutils literal">State</tt>) is simply defined as a <strong>set of attributes</strong>.</p>
<p>Each attribute is designated by a name, defined as an atom, and is associated to a mutable value, which can be any Erlang term.</p>
<p>The current state of an instance can be thought as a list of <tt class="docutils literal">{attribute_name,attribute_value}</tt> pairs, like in:</p>
<pre class="code erlang literal-block">
<span class="punctuation">[</span> <span class="punctuation">{</span><span class="name">color</span><span class="punctuation">,</span><span class="name">black</span><span class="punctuation">},</span> <span class="punctuation">{</span><span class="name">fur_color</span><span class="punctuation">,</span><span class="name">sand</span><span class="punctuation">},</span> <span class="punctuation">{</span><span class="name">age</span><span class="punctuation">,</span><span class="literal number integer">13</span><span class="punctuation">},</span> <span class="punctuation">{</span><span class="name">name</span><span class="punctuation">,</span><span class="literal string">&quot;Tortilla&quot;</span><span class="punctuation">}</span> <span class="punctuation">].</span>
</pre>
</div>
<div class="section" id="state-implementation-details">
<h4><a class="toc-backref" href="#id94">State Implementation Details</a></h4>
<!-- comment Current Implementation -->
<!-- comment ______________________ -->
<!-- comment Starting from the 2.x versions of WOOPER, the list of attributes which defines a state is a class-specific, inheritance-aware, predetermined record. -->
<!-- comment This record gathers exactly all attributes of an instance: the ones that were defined directly in its class, as well as the ones that were inherited, directly or not. -->
<!-- comment This record is defined at compile-time, thanks to parse transforms. Once these mechanisms to determine it have been set-up, it is surely the solution that allows for the best overall performances. -->
<!-- comment So a class developer just has to specify the list of attributes that this class specifically introduces: all other attributes are inherited, and thus will be automatically deduced, at compile-time, from the list of the specified superclasses. -->
<!-- comment Class-specific attributes can be declared with some qualifiers. -->
<!-- comment More generally an attribute can be declared with: -->
<!-- comment - just its name, ex: ``whisker_color`` -->
<!-- comment - a pair made of its name and a single qualifier, ex: ``{fur_color,protected}`` -->
<!-- comment - a pair made of its name and a list of qualifiers, ex: ``{mew_volume,[private,{const,35}]}`` -->
<!-- comment Known attribute qualifiers are: -->
<!-- comment - in terms of accessibility: -->
<!-- comment   - ``public``: for this attribute, a getter/setter pair is automatically generated; for example if ``whisker_color`` is declared as public, then ``getWhiskerColor/1`` and ``setWhiskerColor/2`` are automatically defined by WOOPER -->
<!-- comment   - ``protected``: the attribute can be modified either by the class that defined it or by any of its child classes -->
<!-- comment   - ``private``: the attribute can be modified only by the class that defined it, not by any of its child classes -->
<!-- comment - in terms of mutability: -->
<!-- comment   - ``{const,Value}``: the value of the attribute will never change over time, none can modify it (once an attribute is const, there is no point in specifying that his access is protected or private) -->
<!-- comment Unless specified otherwise, an attribute is protected and non-const. -->
<!-- comment For example an attribute declaration can be:: -->
<!-- comment   % Determines what are the class-specific attributes of this class (if any): -->
<!-- comment   get_attributes() -> -->
<!-- comment      [ {fur_color,protected}, whisker_color, {mew_volume,[private,{const,35}]} ]. -->
<!-- comment Once the instance will be created by WOOPER, the initial state will notably be made of a record, whose fields are exactly the attributes supported by this class, whether they are class-specific or inherited (directly or not). -->
<!-- comment Const attributes will already be set to their associated values, all others being initially set to the value ``undefined``. -->
<!-- comment This empty initial state will be given to the constructor, so that it is able first to call the counterpart constructors of the direct mother classes to update this state, then to set class-specific values afterwards, before returning the resulting state. -->
<p>The conceptual attribute list is actually an associative table <a class="footnote-reference" href="#id15" id="id14">[6]</a> (ultimately relying on the <tt class="docutils literal">map</tt> datatype now; previously on our <tt class="docutils literal">hashtable</tt> module), selected for genericity, dynamicity and efficiency reasons.</p>
<!-- comment (compared to other means of storing entries *a priori*, i.e. without prior knowledge about them). -->
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[6]</a></td><td>A not so conclusive experiment relied on class-specific records being defined. This approach raises issues, for example at construction and destruction time where parent classes have to deal with record types different from their own. Moreover there is no guarantee that creating/destructing longer tuples is significantly more efficient than, say, updating a map (yet the memory footprint shall be lower).</td></tr>
</tbody>
</table>
<p>The hash value of a key (like the <tt class="docutils literal">age</tt> key) is computed, to be used as an index in order to find the corresponding value (in the previous example, <tt class="docutils literal">13</tt>) in the relevant bucket of the table.</p>
<p>The point is that this kind of look-up is performed in constant time on average, regardless of how many key/value pairs are stored in the table, whereas most dynamic data structures, like plain lists, would have look-up runtime costs that would increase with the number of pairs they contain, thus being possibly most often slower than their hashtable-based counterparts.</p>
<!-- comment Using now class-specific fixed records has not real impact on flexibility, and allows for constant-time operations significantly more effective than a hashtable, being both faster, and smaller in memory. -->
<p></p>
</div>
<div class="section" id="managing-the-state-of-an-instance">
<h4><a class="toc-backref" href="#id95">Managing The State Of An Instance</a></h4>
<p>A set of functions allows to operate on these state variables, notably to read and write the attributes that they contain.</p>
<p>As seen in the various examples, method implementations will access (read/write) attributes stored in the instance state, whose original version (i.e. the state of the instance at the method beginning) is always specified as their first parameter, conventionally named <tt class="docutils literal">State</tt>.</p>
<p>This current state can be then modified in the method, and a final state (usually an updated version of the initial one) will be returned locally to WOOPER, thanks to the final statement in the method, one of the two <tt class="docutils literal">wooper_return_state_*</tt> macros.</p>
<p>Then the code (automatically instantiated by the WOOPER header in the class implementation) will loop again for this instance with this updated state, waiting for the next method call, which will possibly change again the state (and trigger side-effects), and so on.</p>
<p>One may refer to <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/src/wooper.hrl">wooper.hrl</a> for the actual definition of most of these WOOPER constructs.</p>
<!-- comment See `wooper.hrl <https://github.com/Olivier-Boudeville/Ceylan-WOOPER/src/wooper.hrl>`_ for the actual definition of most of these WOOPER constructs. -->
<!-- comment These state-management constructs look like functions but, thanks to parse transforms, they are actually inlined for increased performances. -->
<!-- comment As a consequence of the change in the underlying data structure for state variables, following state-management functions have been deprecated for the 2.x versions of WOOPER and onward: ``removeAttribute/2``, ``hasAttribute/2``. -->
<div class="section" id="modifying-state">
<h5>Modifying State</h5>
<div class="section" id="the-setattribute-3-function">
<h6>The <tt class="docutils literal">setAttribute/3</tt> Function</h6>
<p>Setting an attribute (creating and/or modifying it) should be done with the <tt class="docutils literal">setAttribute/3</tt> function:</p>
<pre class="code erlang literal-block">
<span class="name variable">NewState</span> <span class="operator">=</span> <span class="name">setAttribute</span><span class="punctuation">(</span><span class="name variable">AState</span><span class="punctuation">,</span><span class="name variable">AttributeName</span><span class="punctuation">,</span><span class="name variable">NewAttributeValue</span><span class="punctuation">)</span>
</pre>
<p>For example, <tt class="docutils literal">AgeState = setAttribute(State,age,3)</tt> will return a new state, bound to <tt class="docutils literal">AgeState</tt>, exact copy of <tt class="docutils literal">State</tt> (with all the attribute pairs equal) but for the <tt class="docutils literal">age</tt> attribute, whose value will be set to 3.</p>
<!-- comment (whether or not this attribute was already defined in ``State``). -->
<p>Therefore, during the execution of a method, any number of states can be defined (ex: <tt class="docutils literal">State</tt>, <tt class="docutils literal">InitialisedState</tt>, <tt class="docutils literal">AgeState</tt>, etc.) before all, but the one that is returned, are garbage-collected.</p>
<p>Note that the corresponding state duplication remains efficient both in terms of processing and memory, as the different underlying state structures (ex: <tt class="docutils literal">State</tt> and <tt class="docutils literal">AgeState</tt>) actually <strong>share</strong> all their terms except the one modified - thanks to the immutability of Erlang variables which allows to reference rather than copy, be these datastructures tables, records, or anything else.</p>
<p>In various cases, notably in constructors, one needs to define a series of attributes in a row, but chaining <tt class="docutils literal">setAttribute/3</tt> calls with intermediate states that have each to be named is not really convenient.</p>
<p>A better solution is to use the <tt class="docutils literal">setAttributes/2</tt> function (note the plural) to set a list of attribute name/attribute value pairs in a row.</p>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="name variable">ConstructedState</span> <span class="operator">=</span> <span class="name">setAttributes</span><span class="punctuation">(</span><span class="name variable">MyState</span><span class="punctuation">,[{</span><span class="name">age</span><span class="punctuation">,</span><span class="literal number integer">3</span><span class="punctuation">},</span>
                                                                                  <span class="punctuation">{</span><span class="name">whisker_color</span><span class="punctuation">,</span><span class="name">white</span><span class="punctuation">}])</span>
</pre>
<p>will return a new state, exact copy of <tt class="docutils literal">MyState</tt> but for the listed attributes, set to their respective specified value.</p>
</div>
<div class="section" id="the-removeattribute-2-function">
<h6>The <tt class="docutils literal">removeAttribute/2</tt> Function</h6>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="docutils literal">removeAttribute/2</tt> function is now deprecated and should not be used anymore.</p>
</div>
<p>This function was used in order to fully remove an attribute entry (i.e. the whole key/value pair).</p>
<p>This function is deprecated now, as we prefer defining all attributes once for all, at construction time, and never add or remove them dynamically: the good practise is just to operate on their value, which can by example be set to <tt class="docutils literal">undefined</tt>, without having to deal with the fact that, depending on the context, a given attribute may or may not be defined.</p>
<p>For example <tt class="docutils literal">NewState = removeAttribute(State,an_attribute)</tt> could be used, for a resulting state having no key corresponding to <tt class="docutils literal">an_attribute</tt>.</p>
<p>Neither the <tt class="docutils literal">setAttribute*</tt> variants nor <tt class="docutils literal">removeAttribute/2</tt> can fail, regardless of the attribute being already existing or not.</p>
</div>
</div>
<div class="section" id="reading-state">
<h5>Reading State</h5>
<div class="section" id="the-hasattribute-2-function">
<h6>The <tt class="docutils literal">hasAttribute/2</tt> Function</h6>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="docutils literal">hasAttribute/2</tt> function is now deprecated and should not be used anymore.</p>
</div>
<p>To test whether an attribute is defined, one could use the <tt class="docutils literal">hasAttribute/2</tt> function: <tt class="docutils literal">hasAttribute(AState,AttributeName)</tt>, which returns either <tt class="docutils literal">true</tt> or <tt class="docutils literal">false</tt>, and cannot fail.</p>
<p>For example, <tt class="docutils literal">true = hasAttribute(State,whisker_color)</tt> matches if and only if the attribute <tt class="docutils literal">whisker_color</tt> is defined in state <tt class="docutils literal">State</tt>.</p>
<p>Note that generally it is a bad practice to define attributes outside of the constructor of an instance, as the availability of an attribute could then depend on the actual state, which is an eventuality generally difficult to manage reliably.</p>
<p>A better approach is instead to define all possible attributes directly from the constructor. They would then be assigned to their initial value and, if none is appropriate, they should be set to the atom <tt class="docutils literal">undefined</tt> (instead of not being defined at all).</p>
</div>
<div class="section" id="the-getattribute-2-function">
<h6>The <tt class="docutils literal">getAttribute/2</tt> Function</h6>
<p>Getting the value of an attribute is to be done with the <tt class="docutils literal">getAttribute/2</tt> function:</p>
<pre class="code erlang literal-block">
<span class="name variable">AttributeValue</span> <span class="operator">=</span> <span class="name">getAttribute</span><span class="punctuation">(</span><span class="name variable">AState</span><span class="punctuation">,</span><span class="name variable">AttributeName</span><span class="punctuation">)</span>
</pre>
<p>For example, <tt class="docutils literal">MyColor = getAttribute(State,whisker_color)</tt> returns the value of the attribute <tt class="docutils literal">whisker_color</tt> from state <tt class="docutils literal">State</tt>.</p>
<!-- comment The requested attribute may not exist in the specified state. In this case, a compile-time error is issued. -->
<p>The requested attribute may not exist in the specified state. In this case, a runtime error is issued.</p>
<!-- comment With the hashtable-based version of WOOPER, -->
<p>Requesting a non-existing attribute triggers a bad match. In the previous example, should the attribute <tt class="docutils literal">whisker_color</tt> not have been defined, <tt class="docutils literal">getAttribute/2</tt> would return:</p>
<pre class="code erlang literal-block">
<span class="punctuation">{</span><span class="name">key_not_found</span><span class="punctuation">,</span><span class="name">whisker_color</span><span class="punctuation">}</span>
</pre>
</div>
<div class="section" id="the-getattr-2-macro">
<h6>The <tt class="docutils literal">getAttr/2</tt> Macro</h6>
<p>Quite often, when having to retrieve the value of an attribute from a state variable, that variable will be named <tt class="docutils literal">State</tt>, notably when using directly the original state specified in the method declaration.</p>
<p>Indeed, when a method needs a specific value, generally either this value was already available in the state it began with (then we can read it from <tt class="docutils literal">State</tt>), or is computed in the course of the method, in which case that value is most often already bound to a variable, which can then be re-used directly rather than be fetched from a state.</p>
<p>In this case, the <tt class="docutils literal">getAttr/2</tt> macro can be used: <tt class="docutils literal"><span class="pre">?getAttr(whisker_color)</span></tt> expands (literally) as <tt class="docutils literal">getAttribute(State,whisker_color)</tt>, and is a tad shorter.</p>
<p>This is implemented as a macro so that the user remains aware that an implicit variable named <tt class="docutils literal">State</tt> is then used.</p>
<p>The less usual cases where a value must be read from a state variable that is <em>not</em> the initial <tt class="docutils literal">State</tt> one occur mostly when wanting to read a value from the updated state returned by a <tt class="docutils literal">execute*</tt> function call. In this case the <tt class="docutils literal">getAttribute/2</tt> function should be used.</p>
</div>
</div>
<div class="section" id="read-modify-write-operations">
<h5>Read-Modify-Write Operations</h5>
<p>Some additional helper functions are provided for the most common operations, to keep the syntax as lightweight as possible.</p>
<div class="section" id="the-addtoattribute-3-function">
<h6>The <tt class="docutils literal">addToAttribute/3</tt> Function</h6>
<p>When having a numerical attribute, <tt class="docutils literal">addToAttribute/3</tt> adds the specified number to the attribute.</p>
<p>To be used like in:</p>
<pre class="code erlang literal-block">
<span class="name variable">NewState</span> <span class="operator">=</span> <span class="name">addToAttribute</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name variable">AttributeName</span><span class="punctuation">,</span><span class="name variable">Value</span><span class="punctuation">)</span>
</pre>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="name variable">MyState</span> <span class="operator">=</span> <span class="name">addToAttribute</span><span class="punctuation">(</span><span class="name variable">FirstState</span><span class="punctuation">,</span><span class="name">a_numerical_attribute</span><span class="punctuation">,</span><span class="literal number integer">6</span><span class="punctuation">)</span>
</pre>
<p>In <tt class="docutils literal">MyState</tt>, the value of attribute <tt class="docutils literal">a_numerical_attribute</tt> is increased of 6, compared to the one in <tt class="docutils literal">FirstState</tt>.</p>
<p>Calling <tt class="docutils literal">addToAttribute/3</tt> on a non-existing attribute will trigger a runtime error (<tt class="docutils literal">{key_not_found,AttributeName}</tt>).</p>
<p>If the attribute exists, but no addition can be performed on it (i.e. if it is meaningless for the type of the current value), a <tt class="docutils literal">badarith</tt> runtime error will be issued.</p>
<!-- comment With the hashtable-based version of WOOPER: -->
<!-- comment- if the target attribute does not exist, will trigger ``{{badmatch,undefined},[{hashtable,addToEntry,3},..`` -->
<!-- comment- if it exists but no addition can be performed on it (meaningless for the type of the current value), will trigger ``{badarith,[{hashtable,addToEntry,3},..``. -->
</div>
<div class="section" id="the-subtractfromattribute-3-function">
<h6>The <tt class="docutils literal">subtractFromAttribute/3</tt> Function</h6>
<p>When having a numerical attribute, <tt class="docutils literal">subtractFromAttribute/3</tt> subtracts the specified number from the attribute.</p>
<p>To be used like in:</p>
<pre class="code erlang literal-block">
<span class="name variable">NewState</span> <span class="operator">=</span> <span class="name">subtractFromAttribute</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name variable">AttributeName</span><span class="punctuation">,</span><span class="name variable">Value</span><span class="punctuation">)</span>
</pre>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="name variable">MyState</span> <span class="operator">=</span> <span class="name">subtractFromAttribute</span><span class="punctuation">(</span><span class="name variable">FirstState</span><span class="punctuation">,</span><span class="name">a_numerical_attribute</span><span class="punctuation">,</span><span class="literal number integer">7</span><span class="punctuation">)</span>
</pre>
<p>In <tt class="docutils literal">MyState</tt>, the value of attribute <tt class="docutils literal">a_numerical_attribute</tt> is decreased of 7, compared to the one in <tt class="docutils literal">FirstState</tt>.</p>
<p>Calling <tt class="docutils literal">subtractFromAttribute/3</tt> on a non-existing attribute will trigger a runtime error (<tt class="docutils literal">{key_not_found,AttributeName}</tt>).
If the attribute exists, but no subtraction can be performed on it (meaningless for the type of the current value), a <tt class="docutils literal">badarith</tt> runtime error will be issued.</p>
<!-- comment With the hashtable-based version of WOOPER: -->
<!-- comment - if the target attribute does not exist, will trigger ``{{badmatch,undefined},[{hashtable,subtractFromEntry,3},..`` -->
<!-- comment - if it exists but no addition can be performed on it (meaningless for the type of the current value), will trigger ``{badarith,[{hashtable,subtractFromEntry,3},..``. -->
</div>
<div class="section" id="the-toggleattribute-2-function">
<h6>The <tt class="docutils literal">toggleAttribute/2</tt> Function</h6>
<p>Flips the value of the specified (supposedly boolean) attribute: when having a boolean attribute, whose value is either <tt class="docutils literal">true</tt> or <tt class="docutils literal">false</tt>, sets the opposite logical value to the current one.</p>
<p>To be used like in:</p>
<pre class="code erlang literal-block">
<span class="name variable">NewState</span> <span class="operator">=</span> <span class="name">toggleAttribute</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name variable">BooleanAttributeName</span><span class="punctuation">)</span>
</pre>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="name variable">NewState</span> <span class="operator">=</span> <span class="name">toggleAttribute</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name">a_boolean_attribute</span><span class="punctuation">)</span>
</pre>
<p>Calling <tt class="docutils literal">toggleAttribute/2</tt> on a non-existing attribute will trigger a runtime error (<tt class="docutils literal">{key_not_found,AttributeName}</tt>). If the attribute exists, but has not a boolean value, a <tt class="docutils literal">badarith</tt> runtime error will be issued.</p>
<!-- comment With the hashtable-based version of WOOPER: -->
<!-- comment - if the target attribute does not exist, will trigger ``{{case_clause,undefined},[{hashtable,toggleEntry,2},..``. -->
<!-- comment - if it exists but is neither true or false, will trigger ``{{case_clause,{value,..}},[{hashtable,toggleEntry,2},..``. -->
</div>
<div class="section" id="the-appendtoattribute-3-function">
<h6>The <tt class="docutils literal">appendToAttribute/3</tt> Function</h6>
<p>The corresponding signature is <tt class="docutils literal">NewState = appendToAttribute(State,AttributeName,Element)</tt>: when having a list attribute, appends specified element to the attribute list, in first position.</p>
<p>For example, if <tt class="docutils literal">a_list_attribute</tt> was already set to <tt class="docutils literal">[see_you,goodbye]</tt> in <tt class="docutils literal">State</tt>, then after <tt class="docutils literal">NewState = appendToAttribute(State,a_list_attribute,hello)</tt>, the <tt class="docutils literal">a_list_attribute</tt> attribute defined in <tt class="docutils literal">NewState</tt> will be equal to <tt class="docutils literal">[hello,see_you,goodbye]</tt>.</p>
<p>Calling <tt class="docutils literal">appendToAttribute/3</tt> on a non-existing attribute will trigger a compile-time error. If the attribute exists, but is not a list, an ill-formed list will be created (ex: <tt class="docutils literal">[8|false]</tt> when appending 8 to <tt class="docutils literal">false</tt>, which is not a list).</p>
<p>With the hashtable-based version of WOOPER:</p>
<ul class="simple">
<li>if the target attribute does not exist, will trigger <tt class="docutils literal"><span class="pre">{{badmatch,undefined},[{hashtable,appendToEntry,3},..</span></tt>.</li>
<li>if it exists but is not already a list, it will not crash but will create an ill-formed list (ex: <tt class="docutils literal">[8|false]</tt> when appending 8 to <tt class="docutils literal">false</tt>, which is not a list).</li>
</ul>
</div>
<div class="section" id="the-deletefromattribute-3-function">
<h6>The <tt class="docutils literal">deleteFromAttribute/3</tt> Function</h6>
<p>The corresponding signature is <tt class="docutils literal">NewState = deleteFromAttribute(State,AttributeName,Element)</tt>: when having a list attribute, deletes first match of specified element from the attribute list.</p>
<p>For example: <tt class="docutils literal">NewState = deleteFromAttribute(State,a_list_attribute,hello)</tt>, with the value corresponding to the <tt class="docutils literal">a_list_attribute</tt> attribute in <tt class="docutils literal">State</tt> variable being <tt class="docutils literal">[goodbye,hello,cheers,hello,see_you]</tt> should return a state whose <tt class="docutils literal">a_list_attribute</tt> attribute would be equal to <tt class="docutils literal">[goodbye,cheers,hello,see_you]</tt>, all other attributes being unchanged.</p>
<p>If no element in the list matches the specified one, no error will be triggered and the list will be kept as is.</p>
<p>Calling <tt class="docutils literal">deleteFromAttribute/3</tt> on a non-existing attribute will trigger a compile-time error. If the attribute exists, but is not a list, a run-time error will be issued.</p>
<p>With the hashtable-based version of WOOPER:</p>
<ul class="simple">
<li>if the target attribute does not exist, will trigger <tt class="docutils literal"><span class="pre">{{badmatch,undefined},[{hashtable,deleteFromEntry,3},..</span></tt>.</li>
<li>if it exists but is not already a list, it will trigger <tt class="docutils literal"><span class="pre">{function_clause,[{lists,delete,[..,..]},{hashtable,deleteFromEntry,3}</span></tt>.</li>
</ul>
</div>
<div class="section" id="the-popfromattribute-2-function">
<h6>The <tt class="docutils literal">popFromAttribute/2</tt> Function</h6>
<p>The corresponding signature is <tt class="docutils literal">{NewState,Head} = popFromAttribute(State,AttributeName)</tt>: when having an attribute of type list, this function removes the head from the list and returns a pair made of the updated state (same state except that the corresponding list attribute has lost its head, it is equal to the list tail now) and of that head.</p>
<p>For example: <tt class="docutils literal">{NewState,Head} = popFromAttribute(State,a_list_attribute)</tt>. If the value of the attribute <tt class="docutils literal">a_list_attribute</tt> was <tt class="docutils literal">[5,8,3]</tt>, its new value (in <tt class="docutils literal">NewState</tt>) will be <tt class="docutils literal">[8,3]</tt> and <tt class="docutils literal">Head</tt> will be bound to <tt class="docutils literal">5</tt>.</p>
</div>
<div class="section" id="the-addkeyvaluetoattribute-4-function">
<h6>The <tt class="docutils literal">addKeyValueToAttribute/4</tt> Function</h6>
<p>The corresponding signature is <tt class="docutils literal">NewState = addKeyValueToAttribute(State,AttributeName,Key,Value)</tt>: when having an attribute whose value is a table, adds specified key/value pair to that table attribute.</p>
<p>For example: <tt class="docutils literal">TableState = <span class="pre">setAttribute(State,my_table,table:new()),</span> NewState = addKeyValueToAttribute(TableState,my_table,my_key,my_value)</tt> will result in having the attribute <tt class="docutils literal">my_table</tt> in state variable <tt class="docutils literal">TableState</tt> being a table with only one entry, whose key is <tt class="docutils literal">my_key</tt> and whose value is <tt class="docutils literal">my_value</tt>.</p>
<p></p>
</div>
</div>
</div>
</div>
<div class="section" id="multiple-inheritance-polymorphism">
<h3><a class="toc-backref" href="#id96">Multiple Inheritance &amp; Polymorphism</a></h3>
<div class="section" id="the-general-case">
<h4><a class="toc-backref" href="#id97">The General Case</a></h4>
<p>Both multiple inheritance and polymorphism are automatically managed by WOOPER: even if our cat class does not define a <tt class="docutils literal">getAge</tt> method, it can nevertheless readily be called on a cat instance, as it is inherited from its mother classes (here from <tt class="docutils literal">class_Creature</tt>, an indirect mother class).</p>
<p>Therefore all creature instances can be handled the same, regardless of their actual classes:</p>
<pre class="code erlang literal-block">
<span class="comment">% Inherited methods work exactly the same as methods defined
% directly in the class:
</span><span class="name variable">MyCat</span> <span class="operator">!</span> <span class="punctuation">{</span><span class="name">getAge</span><span class="punctuation">,[],</span><span class="name">self</span><span class="punctuation">()},</span>
<span class="keyword">receive</span>
      <span class="punctuation">{</span><span class="name">wooper_result</span><span class="punctuation">,</span><span class="name variable">Age</span><span class="punctuation">}</span> <span class="operator">-&gt;</span>
        <span class="name namespace">io</span><span class="punctuation">:</span><span class="name function">format</span><span class="punctuation">(</span> <span class="literal string">&quot;This is a </span><span class="literal string interpol">~B</span><span class="literal string"> year old cat.&quot;</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="name variable">Age</span><span class="punctuation">]</span> <span class="punctuation">)</span>
<span class="keyword">end</span><span class="punctuation">,</span>

<span class="comment">% Polymorphism is immediate:
% (class_Platypus inheriting too from class_Mammal,
% hence from class_Creature).
</span><span class="name variable">MyPetList</span> <span class="operator">=</span> <span class="punctuation">[</span><span class="name variable">MyCat</span><span class="punctuation">,</span><span class="name variable">MyPlatypus</span><span class="punctuation">],</span>
<span class="name function">foreach</span><span class="punctuation">(</span>
      <span class="keyword">fun</span><span class="punctuation">(</span><span class="name variable">AnyCreature</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
        <span class="name variable">AnyCreature</span> <span class="operator">!</span> <span class="punctuation">{</span><span class="name">getAge</span><span class="punctuation">,[],</span><span class="name">self</span><span class="punctuation">()},</span>
        <span class="keyword">receive</span>
              <span class="punctuation">{</span><span class="name">wooper_result</span><span class="punctuation">,</span><span class="name variable">Age</span><span class="punctuation">}</span> <span class="operator">-&gt;</span>
                <span class="name namespace">io</span><span class="punctuation">:</span><span class="name function">format</span><span class="punctuation">(</span><span class="literal string">&quot;This is a </span><span class="literal string interpol">~B</span><span class="literal string"> year old creature.&quot;</span><span class="punctuation">,[</span><span class="name variable">Age</span><span class="punctuation">])</span>
      <span class="keyword">end</span><span class="punctuation">,</span>
      <span class="name variable">MyPetList</span><span class="punctuation">).</span>
</pre>
<p>Running this code should output something like:</p>
<pre class="literal-block">
This is a 4 year old creature.
This is a 9 year old creature.
</pre>
<p>The point here is that the implementer does not have to know what are the actual classes of the instances that are interacted with, provided that they share a common ancestor: polymorphism allows to handle them transparently.</p>
</div>
<div class="section" id="the-special-case-of-diamond-shaped-inheritance">
<h4><a class="toc-backref" href="#id98">The Special Case of Diamond-Shaped Inheritance</a></h4>
<p>In the case of a <a class="reference external" href="http://en.wikipedia.org/wiki/Diamond_problem">diamond-shaped inheritance</a>, as the method table is constructed in the order specified in the declaration of the superclasses, like in:</p>
<pre class="code erlang literal-block">
<span class="name function">get_superclasses</span><span class="punctuation">()</span> <span class="operator">-&gt;</span>
  <span class="punctuation">[</span><span class="name">class_X</span><span class="punctuation">,</span><span class="name">class_Y</span><span class="punctuation">,...]).</span>
</pre>
<p>and as child classes override mother ones, when an incoming WOOPER message arrives the selected <strong>method</strong> should be the one defined in the last inheritance branch of the last child (if any), otherwise the one defined in the next to last branch of the last child, etc.</p>
<p>Generally speaking, overriding in that case the relevant methods that were initially defined in the child class at the base of the diamond, in order that they perform explicitly a direct call to the wanted module, is by far the most reasonable solution, in terms of clarity and maintainability, compared to guessing which version of the method in the inheritance graph should be called.</p>
<p>Regarding the instance state, the <strong>attributes</strong> are set by the constructors, and the developer can select in which order the direct mother classes should be constructed.</p>
<p>However, in such an inheritance scheme, the constructor of the class that sits at the top of a given diamond will be called multiple times.</p>
<p>Any side-effect that it would induce would then occur as many times as this class is a common ancestor of the actual class; it may be advisable to create idempotent constructors in that case.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">More generally speaking, diamond-shaped inheritance is seldom necessary. More often than not, it is the consequence of a less-than-ideal OOP design, and should be avoided anyway.</p>
</div>
<p></p>
</div>
</div>
<div class="section" id="life-cycle">
<h3><a class="toc-backref" href="#id99">Life-Cycle</a></h3>
<p>Basically, creation and destruction of instances are managed respectively thanks to the <tt class="docutils literal">new</tt>/<tt class="docutils literal">new_link</tt> and the <tt class="docutils literal">delete</tt> operators (all these operators are WOOPER-reserved function names, for all arities), like in:</p>
<pre class="code erlang literal-block">
<span class="name variable">MyCat</span> <span class="operator">=</span> <span class="name namespace">class_Cat</span><span class="punctuation">:</span><span class="name function">new</span><span class="punctuation">(</span><span class="name variable">Age</span><span class="punctuation">,</span><span class="name variable">Gender</span><span class="punctuation">,</span><span class="name variable">FurColor</span><span class="punctuation">,</span><span class="name variable">WhiskerColor</span><span class="punctuation">),</span>
<span class="name variable">MyCat</span> <span class="operator">!</span> <span class="name">delete</span><span class="punctuation">.</span>
</pre>
<div class="section" id="instance-creation-new-new-link-and-construct">
<h4><a class="toc-backref" href="#id100">Instance Creation: <tt class="docutils literal">new</tt>/<tt class="docutils literal">new_link</tt> And <tt class="docutils literal">construct</tt></a></h4>
<div class="section" id="role-of-a-new-construct-pair">
<h5>Role of a  <tt class="docutils literal">new</tt> /<tt class="docutils literal">construct</tt> Pair</h5>
<p>Whereas the purpose of <tt class="docutils literal">new</tt> / <tt class="docutils literal">new_link</tt> is to create a working instance on the user's behalf, the role of <tt class="docutils literal">construct</tt> is to initialise an instance of that class while being able to be chained for inheritance, as explained later.</p>
<p>Such an initialisation is of course part of the instance creation: all calls to any of the``new`` operators result in an underlying call to the (single) corresponding <tt class="docutils literal">construct</tt> operator.</p>
<p>For example, both creations stemming from <tt class="docutils literal">MyCat = class_Cat:new(A,B,C,D)</tt> and <tt class="docutils literal">MyCat = class_Cat:new_link(A,B,C,D)</tt> will rely on <tt class="docutils literal">class_Cat:construct/5</tt> to set up a proper initial state for the <tt class="docutils literal">MyCat</tt> instance; the same <tt class="docutils literal">class_Cat:construct(State,A,B,C,D)</tt> will be called for all creation cases.</p>
<p>The <tt class="docutils literal">new_link</tt> operator behaves exactly as the <tt class="docutils literal">new</tt> operator, except that it creates an instance that is Erlang-linked with the process that called that operator, exactly like <tt class="docutils literal">spawn_link</tt> behaves compared to <tt class="docutils literal">spawn</tt> <a class="footnote-reference" href="#id18" id="id17">[7]</a>.</p>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[7]</a></td><td>For example it induces no race condition between linking and termination in the case of a very short-lived spawned process.</td></tr>
</tbody>
</table>
<p>The <tt class="docutils literal">new</tt> and <tt class="docutils literal">new_link</tt> operators are automatically defined by WOOPER, but they rely on the class-specific user-defined <tt class="docutils literal">construct</tt> operator (only WOOPER is expected to make use of it). This <tt class="docutils literal">construct</tt> operator is the one that must be implemented by the class developer (the machinery related to <tt class="docutils literal">new</tt> being managed by WOOPER).</p>
<p>Currently a single <tt class="docutils literal">construct</tt> operator can be defined, i.e. a single arity is supported <a class="footnote-reference" href="#id20" id="id19">[8]</a>, possibly with multiple clauses that, as usual, are selected based on pattern-matching.</p>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[8]</a></td><td>Even if generally workarounds can easily be devised (for example by tagging construction parameters with atom so that a single arity can federate all cases), this limitation is planned to be removed.</td></tr>
</tbody>
</table>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="comment">% Selection based on pattern-matching:
</span><span class="name variable">MyFirstDog</span>  <span class="operator">=</span> <span class="name variable">Class_Dog</span><span class="punctuation">:</span><span class="name function">new</span><span class="punctuation">(</span><span class="name">create_from_weight</span><span class="punctuation">,</span><span class="literal number integer">4</span><span class="punctuation">.</span><span class="literal number integer">4</span><span class="punctuation">),</span>
<span class="name variable">MySecondDog</span> <span class="operator">=</span> <span class="name variable">Class_Dog</span><span class="punctuation">:</span><span class="name function">new</span><span class="punctuation">(</span><span class="name">create_from_colors</span><span class="punctuation">,[</span><span class="name">sand</span><span class="punctuation">,</span><span class="name">white</span><span class="punctuation">]).</span>
</pre>
</div>
<div class="section" id="the-various-ways-of-creating-an-instance">
<h5>The Various Ways of Creating An Instance</h5>
<p>As shown with the <tt class="docutils literal">new_link</tt> operator, even for a given set of construction parameters, many variations of <tt class="docutils literal">new</tt> can be of use: linked or not, synchronous or not, with a time-out or not, on current node or on a user-specified one, etc.</p>
<p>For a class whose instances can be constructed from <tt class="docutils literal">N</tt> actual parameters, the following construction operators, detailed in the next section, are built-in:</p>
<ul class="simple">
<li>if instance is to be created on the <strong>local</strong> node:<ul>
<li>non-blocking creation: <tt class="docutils literal">new/N</tt> and <tt class="docutils literal">new_link/N</tt></li>
<li>blocking creation: <tt class="docutils literal">synchronous_new/N</tt> and <tt class="docutils literal">synchronous_new_link/N</tt></li>
<li>blocking creation with time-out: <tt class="docutils literal">synchronous_timed_new/N</tt> and <tt class="docutils literal">synchronous_timed_new_link/N</tt></li>
</ul>
</li>
<li>if instance is to be created on any specified <strong>remote</strong> node:<ul>
<li>non-blocking creation: <tt class="docutils literal">remote_new/N+1</tt> and <tt class="docutils literal">remote_new_link/N+1</tt></li>
<li>blocking creation: <tt class="docutils literal">remote_synchronous_new/N+1</tt> and <tt class="docutils literal">remote_synchronous_new_link/N+1</tt></li>
<li>blocking creation with time-out: <tt class="docutils literal">remote_synchronous_timed_new/N+1</tt> and <tt class="docutils literal">remote_synchronous_timed_new_link/N+1</tt></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All <tt class="docutils literal">remote_*</tt> variations require one more parameter (to be specified first), since the remote node on which the instance should be created has of course to be specified.</p>
</div>
<p>All supported <tt class="docutils literal">new</tt> variations are detailed below.</p>
<div class="section" id="asynchronous-new">
<h6>Asynchronous new</h6>
<p>This corresponds to the plain <tt class="docutils literal">new</tt>, <tt class="docutils literal">new_link</tt> operators etc. discussed earlier, relying internally on the usual <tt class="docutils literal">spawn*</tt> primitives . These basic operators are <strong>asynchronous</strong> (non-blocking): they trigger the creation of a new instance, and return immediately, without waiting for it to complete, and the execution of the calling process continues while (hopefully, i.e. with no guarantee) the instance is being created and executed.</p>
</div>
<div class="section" id="synchronous-new">
<h6>Synchronous new</h6>
<p>As mentioned, with the previous asynchronous forms, the caller has no way of knowing when the spawned instance is up and running (if it ever happens).</p>
<p>Thus two counterpart operators, <tt class="docutils literal">synchronous_new/synchronous_new_link</tt> are also available.</p>
<p>They behave like <tt class="docutils literal">new/new_link</tt> except they will return only when (and if) the created instance is up and running: they are blocking, synchronous, operators.</p>
<p>For example, after <tt class="docutils literal">MyMammal = <span class="pre">class_Mammal:synchronous_new(...)</span></tt>, one knows that the <tt class="docutils literal">MyMammal</tt> instance is fully created and waiting for incoming messages.</p>
<p>The implementation of these synchronous operations relies on a message (precisely: <tt class="docutils literal">{spawn_successful,InstancePid}</tt>) being automatically sent by the created instance to the WOOPER code on the caller side, so that the <tt class="docutils literal">synchronous_new</tt> operator will return to the user code only once successfully constructed and ready to handle messages.</p>
</div>
<div class="section" id="timed-synchronous-new">
<h6>Timed Synchronous new</h6>
<p>Note that, should the instance creation fail, the caller of a synchronous new would then be blocked for ever, as the awaited message would actually never be sent by the failed new instance.</p>
<p>This is why the <tt class="docutils literal">synchronous_timed_new*</tt> operators have been introduced: if the caller-side time-out (whose default duration is 5 seconds) expires while waiting for the created instance to answer, then they will throw an appropriate exception, among:</p>
<ul class="simple">
<li><tt class="docutils literal">{synchronous_time_out,InstanceModule}</tt></li>
<li><tt class="docutils literal">{synchronous_linked_time_out,InstanceModule}</tt></li>
<li><tt class="docutils literal">{remote_synchronous_time_out,Node,InstanceModule}</tt></li>
<li><tt class="docutils literal">{remote_synchronous_linked_time_out,Node,InstanceModule}</tt></li>
<li><tt class="docutils literal">{synchronous_time_out,InstanceModule}</tt></li>
<li><tt class="docutils literal">{synchronous_linked_time_out,InstanceModule}</tt></li>
<li><tt class="docutils literal">{remote_synchronous_time_out,Node,InstanceModule}</tt></li>
<li><tt class="docutils literal">{remote_synchronous_linked_time_out,Node,InstanceModule}</tt></li>
</ul>
<p>Then the caller may or may not catch this exception.</p>
<!-- comment return the ``time_out`` atom instead of the PID of the created instance. The caller is then able to check whether the creation succeeded thanks to a simple pattern-matching. -->
</div>
<div class="section" id="remote-new">
<h6>Remote new</h6>
<p>Exactly like a process might be spawned on another Erlang node, a WOOPER instance can be created on any user-specified available Erlang node.</p>
<p>To do so, the <tt class="docutils literal">remote_*new*</tt> variations shall be used. They behave exactly like their local counterparts, except that they take an additional information, as first parameter: the node on which the specified instance must be created.</p>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="name variable">MyCat</span> <span class="operator">=</span> <span class="name namespace">class_Cat</span><span class="punctuation">:</span><span class="name function">remote_new</span><span class="punctuation">(</span><span class="name variable">TargetNode</span><span class="punctuation">,</span> <span class="name variable">Age</span><span class="punctuation">,</span> <span class="name variable">Gender</span><span class="punctuation">,</span>
                                                         <span class="name variable">FurColor</span><span class="punctuation">,</span> <span class="name variable">WhiskerColor</span><span class="punctuation">).</span>
</pre>
<p>Of course:</p>
<ul class="simple">
<li>the remote node must be already existing</li>
<li>the current node must be able to connect to it (shared cookie)</li>
<li>all modules that the instance will make use of must be available on the remote node, including the ones of all relevant classes (i.e. the class of the instance but also its whole class hierarchy)</li>
</ul>
<p>All variations of the <tt class="docutils literal">new</tt> operator are always defined automatically by WOOPER: nothing special is to be done for them, provided of course that the constructor they all rely on has been defined.</p>
</div>
</div>
<div class="section" id="some-examples-of-instance-creation">
<h5>Some Examples Of Instance Creation</h5>
<p>Knowing that a cat can be created out of four parameters (Age, Gender, FurColor, WhiskerColor), various cat instances could be created thanks to:</p>
<pre class="code erlang literal-block">
<span class="comment">% Local asynchronous creation:
</span><span class="name variable">MyFirstCat</span> <span class="operator">=</span> <span class="name namespace">class_Cat</span><span class="punctuation">:</span><span class="name function">new</span><span class="punctuation">(</span><span class="literal number integer">1</span><span class="punctuation">,</span><span class="name">male</span><span class="punctuation">,</span><span class="name">brown</span><span class="punctuation">,</span><span class="name">white</span><span class="punctuation">),</span>

<span class="comment">% The same, but a crash of this cat will crash the current process too:
</span><span class="name variable">MySecondCat</span> <span class="operator">=</span> <span class="name namespace">class_Cat</span><span class="punctuation">:</span><span class="name function">new_link</span><span class="punctuation">(</span><span class="literal number integer">2</span><span class="punctuation">,</span><span class="name">female</span><span class="punctuation">,</span><span class="name">black</span><span class="punctuation">,</span><span class="name">white</span><span class="punctuation">),</span>

<span class="comment">% This cat will be created on OtherNode, and the call will return only
% once it is up and running or once the creation failed. As moreover the
% cat instance is linked to the instance process, it may crash this
% calling process:
</span><span class="name variable">MyThirdCat</span> <span class="operator">=</span> <span class="name namespace">class_Cat</span><span class="punctuation">:</span><span class="name function">remote_synchronous_timed_new_link</span><span class="punctuation">(</span><span class="name variable">OtherNode</span><span class="punctuation">,</span><span class="literal number integer">3</span><span class="punctuation">,</span>
      <span class="name">male</span><span class="punctuation">,</span><span class="name">grey</span><span class="punctuation">,</span><span class="name">black</span><span class="punctuation">),</span>
<span class="punctuation">[..]</span>
</pre>
<!-- Definition of the ``construct`` Operators -->
</div>
<div class="section" id="definition-of-the-construct-operator">
<h5>Definition of the <tt class="docutils literal">construct</tt> Operator</h5>
<!-- Each class must define at least one ``construct`` operator, -->
<p>Each class must define its <tt class="docutils literal">construct/N</tt> operator, whose role is to fully initialise, based on the specified construction parameters, the state of new instances in compliance with the class inheritance - regardless of the <tt class="docutils literal">new</tt> variation being used.</p>
<p>In the context of class inheritance, the <tt class="docutils literal">construct</tt> operators are expected to be chained: they must be designed to be called by the ones of their child classes, and in turn they must call themselves the constructors of their direct mother classes, if any.</p>
<p>Hence they always take the current state of the instance being created as a starting base, and returns it once updated, first from the direct mother classes, then by this class itself.</p>
<p>For example, let's suppose <tt class="docutils literal">class_Cat</tt> inherits directly both from <tt class="docutils literal">class_Mammal</tt> and from <tt class="docutils literal">class_ViviparousBeing</tt>, has only one attribute (<tt class="docutils literal">whisker_color)</tt> of its own, and that a new cat is to be created out of three pieces of information:</p>
<pre class="code erlang literal-block">
<span class="punctuation">[..]</span>
<span class="name function">get_superclasses</span><span class="punctuation">()</span> <span class="operator">-&gt;</span>
      <span class="punctuation">[</span><span class="name">class_Mammal</span><span class="punctuation">,</span><span class="name">class_ViviparousBeing</span><span class="punctuation">].</span>

<span class="punctuation">[..]</span>
<span class="name function">get_attributes</span><span class="punctuation">()</span> <span class="operator">-&gt;</span>
      <span class="punctuation">[</span><span class="name">whisker_color</span><span class="punctuation">].</span>

<span class="comment">% Constructs a new Cat.
</span><span class="name function">construct</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name variable">Gender</span><span class="punctuation">,</span><span class="name variable">FurColor</span><span class="punctuation">,</span><span class="name variable">WhiskerColor</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
      <span class="comment">% First the (chained) direct mother classes:
</span>      <span class="name variable">MammalState</span> <span class="operator">=</span> <span class="name namespace">class_Mammal</span><span class="punctuation">:</span><span class="name function">construct</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,_</span><span class="name variable">Age</span><span class="operator">=</span><span class="literal number integer">0</span><span class="punctuation">,</span><span class="name variable">Gender</span><span class="punctuation">,</span><span class="name variable">FurColor</span><span class="punctuation">),</span>
      <span class="name variable">ViviparousMammalState</span> <span class="operator">=</span> <span class="name namespace">class_ViviparousBeing</span><span class="punctuation">:</span><span class="name function">construct</span><span class="punctuation">(</span><span class="name variable">MammalState</span><span class="punctuation">),</span>
      <span class="comment">% Then the class-specific attributes:
</span>      <span class="name">setAttribute</span><span class="punctuation">(</span><span class="name variable">ViviparousMammalState</span><span class="punctuation">,</span><span class="name">whisker_color</span><span class="punctuation">,</span><span class="name variable">WhiskerColor</span><span class="punctuation">).</span>
</pre>
<p>The fact that the <tt class="docutils literal">Mammal</tt> class itself inherits from the <tt class="docutils literal">Creature</tt> class does not have to appear here: it is to be managed directly by <tt class="docutils literal">class_Mammal:construct</tt> (at any given inheritance level, only direct mother classes must be taken into account).</p>
<p>One should ensure that, in constructors, the successive states are always built from the last updated one, unlike:</p>
<pre class="code erlang literal-block">
<span class="comment">% WRONG, the age update is lost:
</span><span class="name function">construct</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name variable">Age</span><span class="punctuation">,</span><span class="name variable">Gender</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
      <span class="name variable">AgeState</span> <span class="operator">=</span> <span class="name">setAttribute</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name">age</span><span class="punctuation">,</span><span class="name variable">Age</span><span class="punctuation">),</span>
      <span class="comment">% AgeState should be used here, not State:
</span>      <span class="name">setAttribute</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name">gender</span><span class="punctuation">,</span><span class="name variable">Gender</span><span class="punctuation">),</span>
</pre>
<p>This would be correct:</p>
<pre class="code erlang literal-block">
<span class="comment">% RIGHT but a bit clumsy:
</span><span class="name function">construct</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name variable">Age</span><span class="punctuation">,</span><span class="name variable">Gender</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
      <span class="name variable">AgeState</span> <span class="operator">=</span> <span class="name">setAttribute</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name">age</span><span class="punctuation">,</span><span class="name variable">Age</span><span class="punctuation">),</span>
      <span class="name">setAttribute</span><span class="punctuation">(</span><span class="name variable">AgeState</span><span class="punctuation">,</span><span class="name">gender</span><span class="punctuation">,</span><span class="name variable">Gender</span><span class="punctuation">).</span>
</pre>
<p>Recommended form:</p>
<pre class="code erlang literal-block">
<span class="comment">% BEST:
</span><span class="name function">construct</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name variable">Age</span><span class="punctuation">,</span><span class="name variable">Gender</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
      <span class="name">setAttributes</span><span class="punctuation">(</span> <span class="name variable">State</span><span class="punctuation">,</span> <span class="punctuation">[</span> <span class="punctuation">{</span><span class="name">age</span><span class="punctuation">,</span><span class="name variable">Age</span><span class="punctuation">},</span> <span class="punctuation">{</span><span class="name">gender</span><span class="punctuation">,</span><span class="name variable">Gender</span><span class="punctuation">}</span> <span class="punctuation">]).</span>
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>There is no strict relationship between construction parameters and instance attributes, neither in terms of cardinality, type or value.</p>
<p>For examples, attributes could be set to default values, a point could be created from an angle and a distance but its actual state may consist on two cartesian coordinates instead, etc.</p>
<p class="last">Therefore both have to be defined by the class developer, and, in the general case, attributes cannot be inferred from construction parameters.</p>
</div>
<!-- Finally, a class can define multiple constructors: the proper one will be called, based on its arity (determined thanks to the number of parameters specified) and on pattern-matching performed on these parameters, to select the relevant clause of the constructor. -->
<p>Finally, a class can define multiple clauses for its constructor: the proper one will be called based on the pattern-matching performed on these parameters.</p>
</div>
</div>
<div class="section" id="instance-deletion">
<h4><a class="toc-backref" href="#id101">Instance Deletion</a></h4>
<div class="section" id="automatic-chaining-of-destructors">
<h5>Automatic Chaining Of Destructors</h5>
<p>We saw that, when implementing a constructor (<tt class="docutils literal">construct/N</tt>), like in all other OOP approaches the constructors of the direct mother classes have to be explicitly called, so that they can be given the proper parameters, as determined by the class developer.</p>
<p>Conversely, with WOOPER, when defining a destructor for a class (<tt class="docutils literal">destruct/1</tt>), one only has to specify what are the <em>specific</em> operations and state changes (if any) that are required so that an instance of that class is deleted: the proper calling of the destructors of mother classes across the inheritance graph is automatically taken in charge by WOOPER.</p>
<p>Once the user-specified actions have been processed by the destructor (ex: releasing a resource, unsubscribing from a registry, deleting other instances, closing properly a file, etc.), it is expected to return an updated state, which will be given to the destructors of the instance superclasses.</p>
<!-- WOOPER will automatically export and make use of any user-defined destructor, otherwise the de -->
<p>WOOPER will automatically make use of any user-defined destructor, otherwise the default one will be used, doing nothing (i.e. returning the exact same state that it was given).</p>
</div>
<div class="section" id="asynchronous-destruction-using-destruct-1">
<h5>Asynchronous Destruction: using <tt class="docutils literal">destruct/1</tt></h5>
<p>More precisely, either the class implementer does not define at all a <tt class="docutils literal">destruct/1</tt> operator (and therefore uses the default do-nothing destructor), or it defines it explicitly, like in:</p>
<pre class="code erlang literal-block">
<span class="name function">destruct</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
  <span class="name namespace">io</span><span class="punctuation">:</span><span class="name function">format</span><span class="punctuation">(</span><span class="literal string">&quot;An instance of class </span><span class="literal string interpol">~w</span><span class="literal string"> is being deleted now!&quot;</span><span class="punctuation">,[</span><span class="operator">?</span><span class="name variable">MODULE</span><span class="punctuation">]),</span>
  <span class="comment">% Quite often the destructor does not need to modify the state of
</span>  <span class="comment">% the instance:
</span>  <span class="name variable">State</span><span class="punctuation">.</span>
</pre>
<p>In both cases (default or user-defined destructor), when the instance will be deleted (ex: <tt class="docutils literal">MyInstance ! delete</tt> is issued), WOOPER will take care of:</p>
<ul class="simple">
<li>calling any destructor defined for that class</li>
<li>then calling the ones of the direct mother classes, which will in turn call the ones of their mother classes, and so on</li>
</ul>
<p>Note that the destructors for direct mother classes will be called in the reverse order of the one according to the constructors ought to have been called: if a class <tt class="docutils literal">class_X</tt> declares <tt class="docutils literal">class_A</tt> and <tt class="docutils literal">class_B</tt> as mother classes (in that order), then in the <tt class="docutils literal">class_X:construct</tt> definition the implementer is expected to call <tt class="docutils literal">class_A:construct</tt> and then <tt class="docutils literal">class_B:construct</tt>, whereas on deletion the WOOPER-enforced order of execution will be: <tt class="docutils literal">class_X:delete</tt>, then <tt class="docutils literal">class_B:delete</tt>, then <tt class="docutils literal">class_A:delete</tt>, for the sake of symmetry.</p>
</div>
<div class="section" id="synchronous-destruction-using-synchronous-delete-1">
<h5>Synchronous Destruction: using <tt class="docutils literal">synchronous_delete/1</tt></h5>
<p>WOOPER automatically defines as well a way of deleting <em>synchronously</em> a given instance: a caller can request a synchronous (blocking) deletion of that instance so that, once notified of the deletion, it knows for sure the instance does not exist anymore, like in:</p>
<pre class="code erlang literal-block">
<span class="name variable">InstanceToDelete</span> <span class="operator">!</span> <span class="punctuation">{</span><span class="name">synchronous_delete</span><span class="punctuation">,</span><span class="name">self</span><span class="punctuation">()},</span>
<span class="comment">% Then the caller can block as long as the deletion did not occur:
</span><span class="keyword">receive</span>
      <span class="punctuation">{</span><span class="name">deleted</span><span class="punctuation">,</span><span class="name variable">InstanceToDelete</span><span class="punctuation">}</span> <span class="operator">-&gt;</span>
              <span class="name">doSomething</span><span class="punctuation">()</span>
<span class="keyword">end</span><span class="punctuation">.</span>
</pre>
<p>The class implementer does not have to do anything to support this feature, as the synchronous deletion is automatically built by WOOPER on top of the usual asynchronous one (both thus rely on <tt class="docutils literal">destruct/1</tt>).</p>
<p></p>
</div>
</div>
</div>
</div>
<div class="section" id="miscellaneous-technical-points">
<h2><a class="toc-backref" href="#id43">Miscellaneous Technical Points</a></h2>
<div class="section" id="delete-any-instance-referenced-in-2">
<h3><a class="toc-backref" href="#id44"><tt class="docutils literal">delete_any_instance_referenced_in/2</tt></a></h3>
<p>When an attribute contains either a single instance reference (i.e. the PID of the corresponding process) or a list of instance references, this WOOPER-defined helper function will automatically delete (asynchronously) these instances, and will return an updated state in which this attribute is set to <tt class="docutils literal">undefined</tt>.</p>
<p>This function is especially useful in destructors.</p>
<p>For example, if <tt class="docutils literal">State</tt> contains:</p>
<ul class="simple">
<li>an attribute named <tt class="docutils literal">my_pid</tt> whose value is the PID of an instance</li>
<li>and also an attribute named <tt class="docutils literal">my_list_of_pid</tt> containing a list of PID instances</li>
</ul>
<p>and if the deleted instance took ownership of these instances, then:</p>
<pre class="code erlang literal-block">
<span class="name function">delete</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
 <span class="name variable">TempState</span> <span class="operator">=</span> <span class="name namespace">wooper</span><span class="punctuation">:</span><span class="name function">delete_any_instance_referenced_in</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name">my_pid</span><span class="punctuation">),</span>
 <span class="name namespace">wooper</span><span class="punctuation">:</span><span class="name function">delete_any_instance_referenced_in</span><span class="punctuation">(</span><span class="name variable">TempState</span><span class="punctuation">,</span><span class="name">my_list_of_pid</span><span class="punctuation">).</span>
</pre>
<p>will automatically delete all these instances (if any) and return an updated state.</p>
<p>Then the destructors of the mother classes can be chained by WOOPER.</p>
<p>See also the various other helpers defined in <tt class="docutils literal">wooper.erl</tt>.</p>
</div>
<div class="section" id="exit-messages">
<h3><a class="toc-backref" href="#id45"><tt class="docutils literal">EXIT</tt> Messages</a></h3>
<p>A class instance may receive EXIT messages from other processes.</p>
<p>A given class can process these EXIT notifications:</p>
<ul class="simple">
<li>either by defining and exporting the <tt class="docutils literal">onWOOPERExitReceived/3</tt> oneway</li>
<li>or by inheriting it</li>
</ul>
<p>For example:</p>
<pre class="code erlang literal-block">
<span class="name function">onWOOPERExitReceived</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name variable">Pid</span><span class="punctuation">,</span><span class="name variable">ExitType</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
      <span class="name namespace">io</span><span class="punctuation">:</span><span class="name function">format</span><span class="punctuation">(</span><span class="literal string">&quot;MyClass EXIT handler ignored signal '</span><span class="literal string interpol">~p</span><span class="literal string">'&quot;</span>
                        <span class="literal string">&quot; from </span><span class="literal string interpol">~w</span><span class="literal string">.</span><span class="literal string interpol">~n</span><span class="literal string">&quot;</span><span class="punctuation">,</span> <span class="punctuation">[</span><span class="name variable">ExitType</span><span class="punctuation">,</span><span class="name variable">Pid</span><span class="punctuation">]),</span>
      <span class="operator">?</span><span class="name">wooper_return_state_only</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">).</span>
</pre>
<p>may result in an output like:</p>
<pre class="literal-block">
MyClass EXIT handler ignored signal 'normal' from &lt;0.40.0&gt;.
</pre>
<p>If no class-specific EXIT handler is available, the default WOOPER one will be used.</p>
<p>It will just notify the signal to the user, by displaying a message like:</p>
<pre class="literal-block">
WOOPER default EXIT handler for instance &lt;0.36.0&gt; of class class_Cat
  ignored signal 'normal' from &lt;0.40.0&gt;.
</pre>
</div>
<div class="section" id="monitors">
<h3><a class="toc-backref" href="#id46">Monitors</a></h3>
<p>Quite similarly to <tt class="docutils literal">EXIT</tt> messages, monitors and <tt class="docutils literal">nodeup</tt> / <tt class="docutils literal">nodedown</tt> messages are also managed by WOOPER.</p>
</div>
<div class="section" id="id21">
<h3><a class="toc-backref" href="#id47">Type Specifications</a></h3>
<p>We strongly promote at least the definition of types and function specifications, if not a very regular use of <a class="reference external" href="http://erlang.org/doc/man/dialyzer.html">Dialyzer</a>.</p>
<p>Albeit seldom mentioned here, WOOPER defines its own related type constructs in order to apply static typing at its level as well, like in:</p>
<pre class="code erlang literal-block">
<span class="punctuation">-</span><span class="name entity">spec</span> <span class="name">construct</span><span class="punctuation">(</span> <span class="name namespace">wooper</span><span class="punctuation">:</span><span class="name function">state</span><span class="punctuation">(),</span> <span class="name">age</span><span class="punctuation">(),</span> <span class="name">gender</span><span class="punctuation">()</span> <span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="name namespace">wooper</span><span class="punctuation">:</span><span class="name function">state</span><span class="punctuation">().</span>
<span class="punctuation">-</span><span class="name entity">spec</span> <span class="name">destruct</span><span class="punctuation">(</span> <span class="name namespace">wooper</span><span class="punctuation">:</span><span class="name function">state</span><span class="punctuation">()</span> <span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="name namespace">wooper</span><span class="punctuation">:</span><span class="name function">state</span><span class="punctuation">().</span>
<span class="punctuation">-</span><span class="name entity">spec</span> <span class="name">setAge</span><span class="punctuation">(</span> <span class="name namespace">wooper</span><span class="punctuation">:</span><span class="name function">state</span><span class="punctuation">(),</span> <span class="name">age</span><span class="punctuation">()</span> <span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="name">oneway_return</span><span class="punctuation">().</span>
<span class="punctuation">-</span><span class="name entity">spec</span> <span class="name">canEat</span><span class="punctuation">(</span> <span class="name namespace">wooper</span><span class="punctuation">:</span><span class="name function">state</span><span class="punctuation">(),</span> <span class="name">food</span><span class="punctuation">()</span> <span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="name">request_return</span><span class="punctuation">(</span> <span class="name">boolean</span><span class="punctuation">()</span> <span class="punctuation">).</span>
</pre>
<p>Please refer to the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/examples">test examples</a> to better understand their actual use.</p>
</div>
<div class="section" id="guidelines">
<h3><a class="toc-backref" href="#id48">Guidelines</a></h3>
<p>All WOOPER classes must include <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/src/wooper.hrl">wooper.hrl</a>:</p>
<pre class="code erlang literal-block">
<span class="punctuation">-</span><span class="name entity">include</span><span class="punctuation">(</span><span class="literal string">&quot;wooper.hrl&quot;</span><span class="punctuation">).</span>
</pre>
<p>To help declaring the right defines in the right order, using the WOOPER <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/examples/class_WOOPERTemplate.erl.sample">template</a> is recommended.</p>
<p>One may also have a look at the full <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/examples">test examples</a>, as a source of inspiration.</p>
<!-- comment Note:: To be updated, notably with respect to parse transforms. -->
</div>
<div class="section" id="source-editors">
<h3><a class="toc-backref" href="#id49">Source Editors</a></h3>
<p>We use <tt class="docutils literal">Emacs</tt> but of course any editor will be fine.</p>
<p>For Nedit users, a WOOPER-aware <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Myriad/blob/master/conf/nedit.rc">nedit.rc</a> configuration file for syntax highlighting (on black backgrounds), inspired from Daniel Solaz's <a class="reference external" href="http://www.trapexit.org/forum/viewtopic.php?p=30189">Erlang Nedit mode</a>, is available.</p>
</div>
<div class="section" id="similarity-with-other-languages">
<h3><a class="toc-backref" href="#id50">Similarity With Other Languages</a></h3>
<p>Finally, WOOPER is in some ways adding features quite similar to the ones available with other languages, including Python (simple multiple inheritance, implied <tt class="docutils literal">self/State</tt> parameter, attribute dictionaries/associative tables, etc.; with less syntactic sugar available though) while still offering the major strengths of Erlang (concurrency, distribution, functional paradigm) and not hurting too much the overall performances (mainly thanks to the prebuilt attribute and method tables).</p>
<p>Actually the main implementation shortcomings that remain are:</p>
<ul class="simple">
<li>some syntactical elements are still too cumbersome (ex: the <tt class="docutils literal">wooper_construct_export</tt> declaration, which moreover hinders from being able to declare constructors with various arities)</li>
<li>the per-instance memory footprint could be reduced by sharing the &quot;virtual table&quot; of a given class between all its instances</li>
</ul>
<p>Both of these limitations are to be removed over time thanks to metaprogramming (based on parse transforms).</p>
<!-- Although the hashtable-based version of WOOPER is as permissive as Python, allowing to define dynamically new attributes at any time (i.e. outside of the "constructor"), the newer WOOPER versions enforce a stricter attribute management, closer to the one of languages like C++ or Java. -->
<p></p>
</div>
</div>
<div class="section" id="wooper-example">
<h2><a class="toc-backref" href="#id51">WOOPER Example</a></h2>
<p>We defined a small set of classes in order to serve as an example and demonstrate multiple inheritance:</p>
<p><span class="raw-html"><center><img src="wooper-example.png" width="70%" alt="WOOPER Example"></img></center></span>
</p>
<div class="section" id="class-implementations">
<h3><a class="toc-backref" href="#id52">Class implementations</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/examples/class_Creature.erl">class_Creature.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/examples/class_ViviparousBeing.erl">class_ViviparousBeing.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/examples/class_OvoviviparousBeing.erl">class_OvoviviparousBeing.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/examples/class_Mammal.erl">class_Mammal.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/examples/class_Reptile.erl">class_Reptile.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/examples/class_Cat.erl">class_Cat.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/examples/class_Platypus.erl">class_Platypus.erl</a></li>
</ul>
</div>
<div class="section" id="tests">
<h3><a class="toc-backref" href="#id53">Tests</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/examples/class_Creature_test.erl">class_Creature_test.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/examples/class_ViviparousBeing_test.erl">class_ViviparousBeing_test.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/examples/class_OvoviviparousBeing_test.erl">class_OvoviviparousBeing_test.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/examples/class_Mammal_test.erl">class_Mammal_test.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/examples/class_Reptile_test.erl">class_Reptile_test.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/examples/class_Cat_test.erl">class_Cat_test.erl</a></li>
<li><a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/tree/master/examples/class_Platypus_test.erl">class_Platypus_test.erl</a></li>
</ul>
<p>To run a test (ex: <tt class="docutils literal">class_Cat_test.erl</tt>), when WOOPER has already been compiled, one just has to enter: <tt class="docutils literal">make class_Cat_run</tt>.</p>
<p></p>
</div>
</div>
<div class="section" id="good-practises">
<h2><a class="toc-backref" href="#id54">Good Practises</a></h2>
<p>When using WOOPER, the following conventions are deemed useful to respect.</p>
<p>No warning should be tolerated in code using WOOPER, as we never found useless notifications.</p>
<!-- With the hashtable-based version of WOOPER, -->
<p>All attributes of an instance should better be defined from the constructor, instead of being dynamically added during the life of the instance; otherwise the methods would have to deal with some attributes that may, or may not, be defined; if no proper value exists for an attribute at the creation of an instance, then its value should just be set to the atom <tt class="docutils literal">undefined</tt>.</p>
<p>When a function or a method is defined in a WOOPER file, it should of course be commented, and, even if the information can be guessed from context and body, in the last line of the comments the type of the function should be specified (ex: <tt class="docutils literal">oneway</tt>, <tt class="docutils literal">request</tt>, <tt class="docutils literal">helper function</tt>, etc.) possibly with qualifiers (ex: <tt class="docutils literal">const</tt>), like in:</p>
<pre class="code erlang literal-block">
<span class="comment">% Sets the current color.
% (oneway)
</span><span class="name function">setColor</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name variable">NewColor</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
      <span class="punctuation">[..]</span>
</pre>
<p>or:</p>
<pre class="code erlang literal-block">
<span class="comment">% Gets the current color.
% (const request)
</span><span class="name function">getColor</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
      <span class="punctuation">[..]</span>
</pre>
<p>Helper functions and static methods (which, from an Erlang point of view, are just exported functions) should be named like C functions (ex: <tt class="docutils literal">compute_sum</tt>) rather than being written in CamelCase (ex: no helper function should be named <tt class="docutils literal">computeSum</tt>), to avoid mixing up these different kinds of code.</p>
<p>To further separate helper functions from instance methods, an helper function taking a <tt class="docutils literal">State</tt> parameter should better place it at the end of its parameter list rather than in first position (ex: <tt class="docutils literal">compute_sum(X,Y,State)</tt> rather than <tt class="docutils literal">compute_sum(State,X,Y)</tt>).</p>
<p>In a method body, the various state variables being introduced should be properly named, i.e. their name should start with a self-documenting prefix followed by the <tt class="docutils literal">State</tt> suffix, like in: <tt class="docutils literal">SeededState = <span class="pre">setAttribute(State,seed,{1,7,11})</span></tt>.</p>
<p>Some more general (mostly unrelated) Erlang conventions that we like:</p>
<ul class="simple">
<li>when more than one parameter is specified in a fonction signature, parameter names can be surrounded by spaces (ex: <tt class="docutils literal">f( Color )</tt>, or <tt class="docutils literal">g( Age, Height )</tt>)</li>
<li>functions should be separated by (at least) three newlines, whereas clauses for a given function should be separated exactly by one newline</li>
<li>to auto-document parameters, a &quot;mute&quot; variable is preferably to be used: for example, instead of <tt class="docutils literal">f( Color, true )</tt> use <tt class="docutils literal">f( Color, _Dither=true )</tt>; however note that these mute variables are still bound and thus pattern-matched: for example, if multiple <tt class="docutils literal">_Dither</tt> mute variables are bound in the same scope to different values, a bad match will be triggered at runtime.</li>
</ul>
<p></p>
</div>
<div class="section" id="troubleshooting">
<h2><a class="toc-backref" href="#id55">Troubleshooting</a></h2>
<div class="section" id="general-case">
<h3><a class="toc-backref" href="#id56">General Case</a></h3>
<div class="section" id="compilation-warnings">
<h4>Compilation Warnings</h4>
<p>A basic rule of thumb in all languages is to enable all warnings and eradicate them before even trying to test a program.</p>
<p>This is still more valid when using WOOPER, whose proper use should never result in any warning being issued by the compiler.</p>
<p>Notably warnings about unused variables are precious in order to catch mistakes when state variables are not being properly taken care of (ex: when a state is defined but never re-used later).</p>
</div>
<div class="section" id="runtime-errors">
<h4>Runtime Errors</h4>
<p>Most errors while using WOOPER should result in relatively clear messages (ex: <tt class="docutils literal">wooper_method_failed</tt> or <tt class="docutils literal">wooper_method_faulty_return</tt>), associated with all relevant run-time information that was available to WOOPER.</p>
<p>Another way of overcoming WOOPER issues is to activate the debug mode for all WOOPER-enabled compiled modules (ex: uncomment <tt class="docutils literal"><span class="pre">-define(wooper_debug,).</span></tt> in <tt class="docutils literal">wooper.hrl</tt>), and recompile your classes.</p>
<p>The debug mode tries to perform extensive checking on all WOOPER entry points, from incoming messages to the user class itself, catching mistakes from the class developer as well as from the class user.</p>
<p>For example, the validity of states returned by a constructor, by each method and by the destructor is checked, as the one of states specified to the <tt class="docutils literal">execute*</tt> constructs.</p>
<p>If it is not enough to clear things up, an additional step can be to add, on a per-class basis (ex: in <tt class="docutils literal">class_Cat.erl</tt>), before the WOOPER include, <tt class="docutils literal"><span class="pre">-define(wooper_log_wanted,).</span></tt>.</p>
<p>Then all incoming method calls will be traced, for easier debugging. It is seldom necessary to go till this level of detail.</p>
<p>As there are a few common WOOPER gotchas though, the main ones are listed below.</p>
<div class="section" id="mismatches-in-method-call">
<h5>Mismatches In Method Call</h5>
<div class="section" id="oneway-versus-request-calls">
<h6>Oneway Versus Request Calls</h6>
<p>One of these gotchas - experienced even by the WOOPER author - is to define a two-parameter oneway, whose second parameter is a PID, and to call this method wrongly as a request, instead of as a oneway.</p>
<p>For example, let's suppose the <tt class="docutils literal">class_Dog</tt> class defines the oneway method <tt class="docutils literal">startBarkingAt/3</tt> as:</p>
<pre class="code erlang literal-block">
<span class="name function">startBarkingAt</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name variable">Duration</span><span class="punctuation">,</span><span class="name variable">ListenerPID</span><span class="punctuation">)</span> <span class="operator">-&gt;</span> <span class="punctuation">...</span>
</pre>
<p>The correct approach to call this <strong>oneway</strong> would be:</p>
<pre class="code erlang literal-block">
<span class="name variable">MyDogPid</span> <span class="operator">!</span> <span class="punctuation">{</span><span class="name">startBarkingAt</span><span class="punctuation">,[</span><span class="name variable">MyDuration</span><span class="punctuation">,</span><span class="name">self</span><span class="punctuation">()]}</span>
</pre>
<p>An absent-minded developer could have written instead:</p>
<pre class="code erlang literal-block">
<span class="name variable">MyDogPid</span> <span class="operator">!</span> <span class="punctuation">{</span><span class="name">startBarkingAt</span><span class="punctuation">,</span><span class="name variable">MyDuration</span><span class="punctuation">,</span><span class="name">self</span><span class="punctuation">()}</span>
</pre>
<p>This would have called a <tt class="docutils literal">request</tt> method <tt class="docutils literal">startBarkingAt/2</tt> (which could have been for example <tt class="docutils literal">startBarkingAt(State,TerminationOffset) <span class="pre">-&gt;</span> ...</tt>, the PID being interpreted by WOOPER as the request sender PID), a method that most probably does not even exist.</p>
<p>This would result in a bit obscure error message like <tt class="docutils literal">Error in process &lt;0.43.0&gt; on node 'XXXX' with exit value: <span class="pre">{badarg,[{class_Dog,wooper_main_loop,1}]}</span></tt>.</p>
</div>
<div class="section" id="list-parameter-incorrectly-specified-in-call">
<h6>List Parameter Incorrectly Specified In Call</h6>
<!-- no link generated: As explained in the `single method parameter is a list`_ section, -->
<p>As explained in the <a class="reference internal" href="#method-parameters">Method Parameters</a> section,
if a method takes only one parameter and if this parameter is a list, then in a call this parameter cannot be specified as a standalone one: a parameter list with only one element, this parameter, should be used instead.</p>
</div>
</div>
<div class="section" id="error-with-exit-value-undef-map-hashtable-new">
<h5>Error With Exit Value: <tt class="docutils literal"><span class="pre">{undef,[{map_hashtable,new,[..]}..</span></tt></h5>
<!-- You most probably are using the hashtable-based version of WOOPER and you forgot to build the ``common`` directory, which, among other things, contains the ``hashtable.erl`` source file. -->
<p>You most probably forgot to build the <tt class="docutils literal">common</tt> directory (a.k.a. <tt class="docutils literal"><span class="pre">Ceylan-Myriad</span></tt>) that contains, among other modules, the <tt class="docutils literal">map_hashtable.erl</tt> source file.</p>
<p>Check that you have a <tt class="docutils literal">map_hashtable.beam</tt> file indeed, and that it can be found from the paths specified to the virtual machine. Note that the WOOPER code designates this module as the <tt class="docutils literal">table</tt> one (ex: <tt class="docutils literal">table:new()</tt>), for a better substituability (this is obtained thanks to a parse-transform provided by <tt class="docutils literal"><span class="pre">Ceylan-Myriad</span></tt>) .</p>
<p></p>
</div>
</div>
</div>
</div>
<div class="section" id="current-stable-version-download">
<h2><a class="toc-backref" href="#id57">Current Stable Version &amp; Download</a></h2>
<div class="section" id="using-stable-release-archive">
<h3><a class="toc-backref" href="#id58">Using Stable Release Archive</a></h3>
<!-- WOOPER 2.0 is ready to be used and can be downloaded `here <http://sourceforge.net/project/showfiles.php?group_id=158516&package_id=239574>`_ (FIXME). -->
<!-- Either a ``.zip`` or a ``.tar.bz2`` can be retrieved. WOOPER has been fully functional (pun intended!), starting from its 0.1 version. -->
<!-- One way of building all of WOOPER (base files and examples) is, from UNIX or on Windows from a Cygwin or MSYS shell, once the archive is downloaded and extracted, to execute ``make all`` from the WOOPER directory. -->
<!-- comment For example:: -->
<!-- $ tar xvjf wooper-x.y.tar.bz2 && cd wooper-x.y && make all -->
<!-- It will build and run all, including the various WOOPER test cases. -->
<p>Currently no source archive is specifically distributed, please refer to the following section.</p>
</div>
<div class="section" id="using-cutting-edge-git">
<h3><a class="toc-backref" href="#id59">Using Cutting-Edge GIT</a></h3>
<p>We try to ensure that the main line (in the <tt class="docutils literal">master</tt> branch) always stays functional. Evolutions are to be take place in feature branches.</p>
<p>This layer, <tt class="docutils literal"><span class="pre">Ceylan-WOOPER</span></tt>, relies (only) on:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.erlang.org/">Erlang</a>, version 20.2 or higher</li>
<li>the <tt class="docutils literal"><span class="pre">Ceylan-Myriad</span></tt> base layer</li>
</ul>
<p>We prefer using GNU/Linux, sticking to the latest stable release of Erlang, and building it from sources, thanks to GNU <tt class="docutils literal">make</tt>.</p>
<p>For that we devised the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Myriad/blob/master/conf/install-erlang.sh">install-erlang.sh</a> script; a simple use of it is:</p>
<pre class="code bash literal-block">
$ ./install-erlang.sh --doc-install --generate-plt
</pre>
<p>One may execute <tt class="docutils literal"><span class="pre">./install-erlang.sh</span> <span class="pre">--help</span></tt> for more details about how to configure it, notably in order to enable all modules of interest (<tt class="docutils literal">crypto</tt>, <tt class="docutils literal">wx</tt>, etc.) even if they are optional in the context of WOOPER.</p>
<p>As a result, once a proper Erlang version is available, the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-Myriad">Ceylan-Myriad repository</a> should be cloned and built, before doing the same with the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER">Ceylan-WOOPER repository</a>, like in:</p>
<pre class="code bash literal-block">
$ git clone https://github.com/Olivier-Boudeville/Ceylan-Myriad
$ <span class="name builtin">cd</span> Ceylan-Myriad <span class="operator">&amp;&amp;</span> make all <span class="operator">&amp;&amp;</span> <span class="name builtin">cd</span> ..
<span class="comment single"># WOOPER knows this package as the 'Common' layer:
</span>$ ln -s Ceylan-Myriad common
$ git clone https://github.com/Olivier-Boudeville/Ceylan-WOOPER
$ <span class="name builtin">cd</span> Ceylan-WOOPER <span class="operator">&amp;&amp;</span> make all
</pre>
<!-- On UNIX-like platforms, using the Makefiles included in the WOOPER archive is recommended. -->
<!-- One just has to go at the root of the sources (from an extracted archive, you are expected to be in the ``wooper-x.y`` root directory) and simply run: ``make`` (assuming GNU ``make`` is available, so that the WOOPER ``GNUmakefile`` is used). -->
<!-- comment On other platforms, these modules must be compiled one way or another before using WOOPER. For example -->
<!-- 1> c(wooper_class_manager). -->
<!-- {ok,wooper_class_manager} -->
<p></p>
</div>
</div>
<div class="section" id="version-history-changes">
<h2><a class="toc-backref" href="#id60">Version History &amp; Changes</a></h2>
<p>As mentioned previously, in the future a version of WOOPER making heavy use of parse-transforms will be distributed.</p>
<!-- Here is their mapping to actual released versions: -->
<!-- :raw-html:`<img src="wooper-versions.png"></img>` -->
<!-- :raw-latex:`\includegraphics[scale=0.34]{wooper-versions.png}` -->
<!-- .. contents:: Versions -->
<!-- :local: -->
<!-- :depth: 1 -->
<div class="section" id="version-2-0-cutting-edge-not-available">
<h3><a class="toc-backref" href="#id61">Version 2.0 [cutting-edge, not available]</a></h3>
<p>Not released yet (work-in-progress).</p>
</div>
<div class="section" id="version-1-0-current-stable">
<h3><a class="toc-backref" href="#id62">Version 1.0 [current stable]</a></h3>
<p>Countless improvements have been integrated in the course of the use of WOOPER, which has been now been stable for years.</p>
<p>Since 2016 we switched back to a &quot;rolling release&quot;, not defining specific versions.</p>
<p>The main change since the 0.4 version is the use of the newly-introduced <tt class="docutils literal">map</tt> Erlang datatype, resulting in the <tt class="docutils literal">hashtable</tt> module being replaced by the <tt class="docutils literal">map_hashtable</tt>. They obey to the same API and the <tt class="docutils literal">table</tt> pseudo-type abstracts out the actual choice in that matter (it is transparently parse-transformed into the currently-retained datatype).</p>
<!-- This was the latest stable version of the legacy WOOPER branch, which ranges from the 0.x series to the 1.x series. Although now the 2.x series is the recommended one, it does not fully deprecate this branch as some (rather uncommon) use cases might find the mode of operation of the 1.x series, which is based on hashtables rather than on parse transforms, more suitable. -->
<!-- Indeed, contrary to more recent versions, this 1.x series allows for example attributes to be dynamically added and removed (which is, however, usually considered as a bad practise). -->
<!-- The memory footprint of instances of the 1.x series is generally significantly higher, as for the execution durations. -->
<!-- Note finally that instances from either series are fully interoperable. -->
<!-- The latest stable version of that branch can be found in: -->
<!-- - `wooper-1.0.tar.bz2 <http://downloads.sourceforge.net/ceylan/wooper-1.0.tar.bz2>`_ -->
<!-- - `wooper-1.0.zip <http://downloads.sourceforge.net/ceylan/wooper-1.0.zip>`_ -->
<!-- This milestone version is almost exactly the same as the previous 0.4 version. -->
</div>
<div class="section" id="version-0-4">
<h3><a class="toc-backref" href="#id63">Version 0.4</a></h3>
<p>It is mainly a BFO (<em>Bug Fixes Only</em>) version, as functional coverage is pretty complete already.</p>
<p>Main changes are:</p>
<ul class="simple">
<li>debug mode enhanced a lot: many checkings are made at all fronteers between WOOPER and either the user code (messages) or the class code (constructors, methods, destructor, execute requests); user-friendly explicit error messages are displayed instead of raw errors in most cases; <tt class="docutils literal">is_record</tt> used to better detect when an expected state is not properly returned</li>
<li><tt class="docutils literal">wooper_result</tt> not appended any more to method returns in debug mode</li>
<li>release mode tested and fixed</li>
<li><tt class="docutils literal">exit</tt> replaced by <tt class="docutils literal">throw</tt>, use of newer and better <tt class="docutils literal">try/catch</tt> instead of mere <tt class="docutils literal">catch</tt></li>
<li>destructor chained calls properly fixed this time</li>
<li><tt class="docutils literal">delete_any_instance_referenced_in/2</tt> added, <tt class="docutils literal">wooper_return_state_*</tt> macros simplified, <tt class="docutils literal">remote_*</tt> bug fixed</li>
</ul>
</div>
<div class="section" id="version-0-3">
<h3><a class="toc-backref" href="#id64">Version 0.3</a></h3>
<p>Released on Wednesday, March 25, 2009.</p>
<p>Main changes are:</p>
<ul class="simple">
<li>destructors are automatically chained as appropriate, and they can be overridden at will</li>
<li>incoming EXIT messages are caught by a default WOOPER handler which can be overridden on a per-class basis by the user-specified <tt class="docutils literal">onWOOPERExitReceived/3</tt> method</li>
<li>direct method invocation supported, thanks to the <tt class="docutils literal">executeRequest</tt> and <tt class="docutils literal">executeOneway</tt> constructs, and <tt class="docutils literal">wooper_result</tt> no more appended to the result tuple</li>
<li>synchronous spawn operations added or improved: <tt class="docutils literal">synchronous_new/synchronous_new_link</tt> and al; corresponding template updated</li>
<li>state management enriched: <tt class="docutils literal">popFromAttribute</tt> added</li>
<li>all new variations on remote nodes improved or added</li>
<li>major update of the documentation</li>
</ul>
</div>
<div class="section" id="version-0-2">
<h3><a class="toc-backref" href="#id65">Version 0.2</a></h3>
<p>Released on Friday, December 21, 2007. Still fully functional!</p>
<p>Main changes are:</p>
<ul class="simple">
<li>the sender PID is made available to requests in the instance state variable (see <tt class="docutils literal">request_sender</tt> member, used automatically by the <tt class="docutils literal">getSender</tt> macro)</li>
<li>runtime errors better identified and notified</li>
<li>macros for attribute management added, existing ones more robust and faster</li>
<li>fixed a potential race condition when two callers request nearly at the same time the WOOPER class manager (previous mechanism worked, class manager was a singleton indeed, but second caller was not notified)</li>
<li>improved build (Emakefile generated), comments, error output</li>
<li>test template added</li>
<li>documentation updated</li>
</ul>
</div>
<div class="section" id="version-0-1">
<h3><a class="toc-backref" href="#id66">Version 0.1</a></h3>
<p>Released on Sunday, July 22, 2007. Already fully functional!</p>
<p></p>
</div>
</div>
<div class="section" id="wooper-inner-workings">
<h2><a class="toc-backref" href="#id67">WOOPER Inner Workings</a></h2>
<p>Each instance runs a main loop (<tt class="docutils literal">wooper_main_loop/1</tt>, defined in <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER/blob/master/src/wooper.hrl">wooper.hrl</a>) that keeps its internal state and, through a blocking <tt class="docutils literal">receive</tt>, serves the methods as specified by incoming messages, quite similarly to a classical server that loops on an updated state, like in:</p>
<pre class="code erlang literal-block">
<span class="name function">my_server</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">)</span> <span class="operator">-&gt;</span>
  <span class="keyword">receive</span>
        <span class="punctuation">{</span><span class="name">command</span><span class="punctuation">,{</span><span class="name variable">M</span><span class="punctuation">,</span><span class="name variable">P</span><span class="punctuation">}}</span> <span class="operator">-&gt;</span>
          <span class="name variable">NewState</span> <span class="operator">=</span> <span class="name">execute_command</span><span class="punctuation">(</span><span class="name variable">State</span><span class="punctuation">,</span><span class="name variable">M</span><span class="punctuation">,</span><span class="name variable">P</span><span class="punctuation">),</span>
          <span class="name">my_server</span><span class="punctuation">(</span><span class="name variable">NewState</span><span class="punctuation">)</span>
  <span class="keyword">end</span><span class="punctuation">.</span>
</pre>
<p>In each instance, WOOPER manages the tail-recursive infinite surrounding loop, <tt class="docutils literal">State</tt> corresponding to the (private) state of the instance, and <tt class="docutils literal">execute_command(State,M,P)</tt> corresponding to the WOOPER logic that triggers the user-defined method <tt class="docutils literal">M</tt> with the current state (<tt class="docutils literal">State</tt>) and the specified parameters (<tt class="docutils literal">P</tt>), and that may return a result.</p>
<p>The per-instance kept state is twofold, in the sense that it contains two associative tables, one to route method calls and one to store the instance attributes, as explained below.</p>
<div class="section" id="method-virtual-table">
<h3><a class="toc-backref" href="#id68">Method Virtual Table</a></h3>
<div class="section" id="general-principle">
<h4>General Principle</h4>
<p>This associative table allows, for a given class, to determine which module implements actually each supported method.</p>
<p>For example, all instances of <tt class="docutils literal">class_Cat</tt> have to know that their <tt class="docutils literal">getWhiskerColor/1</tt> method is defined directly in that class, as opposed to their <tt class="docutils literal">setAge/2</tt> method whose actual implementation is to be found, say, in <tt class="docutils literal">class_Mammal</tt>, should this class have overridden it from <tt class="docutils literal">class_Creature</tt>.</p>
<p>As performing a method look-up through the entire inheritance graph at each call would waste resources, the look-up is precomputed for each class.</p>
<!-- Implementation In WOOPER version 2.0 and more recent -->
<!-- .................................................... -->
<!-- The association from a method name to a module name is done at compilation-time: an appropriate parse transform determines the mapping for each class, and automatically adds it to the generated BEAM. -->
<!-- For example, the ``class_Cat:getWhiskerColor/1`` function is left untouched (except that it is exported, if listed in ``get_member_methods/0``), but  ``class_Cat:setAge/2`` now directly links to ``class_Mammal:setAge/2``, so that the minimal run-time overhead is incurred when a cat instance receives a call to that method. -->
<!-- As a result, this virtual table can be considered as being directly embedded in the code of the module (in the BEAM file), resulting, in terms of memory, in a null per-instance overhead for this virtual table. -->
<!-- Implementation In Hashtable-Based WOOPER versions -->
<!-- ................................................. -->
<p>Indeed a per-class table is built at runtime, on the first creation of an instance of this class, and stored by the unique (singleton) WOOPER class manager that shares it to all the class instances.</p>
<p>This manager is itself spawned the first time it is needed, and stays ready for all instances of various classes being created (it uses a table to associate to each class its specific virtual table).</p>
<p>This per-class method table has for keys the known method names (atoms) for this class, associated to the values being the most specialised module, in the inheritance graph, that defines that method.</p>
<p>Hence each instance has a reference to a shared table that allows for a direct method look-up.</p>
<p>As the table is built only once and is theoritically shared by all instances <a class="footnote-reference" href="#id26" id="id25">[9]</a>, it adds very little overhead, space-wise and time-wise. Thanks to the table, method look-up is expected to be quite efficient too (constant-time).</p>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[9]</a></td><td>Provided that Erlang does not copy these shared immutable structures, which unfortunately does not seem to be currently the case with the vanilla virtual machine. In a later version of WOOPER, the per-class table will be precompiled and shared as a module, thus fully removing that per-instance overhead.</td></tr>
</tbody>
</table>
<!-- (except for binaries, which are of no use here), inducing a large per-instance overhead which, in turn, reduces a lot the scalability that can be achieved thanks to these WOOPER versions. -->
</div>
</div>
<div class="section" id="attribute-table">
<h3><a class="toc-backref" href="#id69">Attribute Table</a></h3>
<!-- Implementation In WOOPER version 2.0 and more recent -->
<!-- .................................................... -->
<!-- At compile-time, a parse transform reads the attributes declared thanks to the ``get_attributes/0`` function for the current class and, recursively, for all mother classes (direct or not). -->
<!-- Note that, regardless of all qualifiers, a class is not allowed to define an attribute whose name is the same of an inherited one, to prevent collisions (even if both attributes are declared private). -->
<!-- Once having determined the full list of attributes for that class, the parse transform generates a class-specific record to hold them, each attribute being mapped into a first-level field of the record. -->
<!-- Note that even if a record is defined for the mammal class and if the mammal attributes form a subset of the cat ones, the cat record will not include the mammal one: it will define its own record, with all attributes at the same level (no nesting). -->
<!-- Then the state of each of the class instances will be based on these class-specific records, and the state-management functions (like ``setAttribute``) are translated at compile-time (inlined) as statements operating on instances of these records. -->
<!-- The default getter/setter methods are automatically defined for public attributes. -->
<!-- Implementation In Hashtable-Based WOOPER versions -->
<!-- ................................................. -->
<p>This is another associative table, this time necessarily per-instance.</p>
<p>Keys are attribute names of that instance, values are the corresponding attribute values.</p>
<p>It allows a simple, seamless yet efficient access to all data members, including inherited ones.</p>
<p></p>
</div>
</div>
<div class="section" id="issues-planned-enhancements">
<h2><a class="toc-backref" href="#id70">Issues &amp; Planned Enhancements</a></h2>
<!-- For all versions of WOOPER: -->
<ul class="simple">
<li>test the impact of using HiPE by default</li>
<li>integrate automatic persistent storage of instance states, for example in Mnesia databases</li>
<li>add a mode to support <em>passive</em> instances, i.e. pure data-structures not hosted by a specific process; should be as easy as introducing a <tt class="docutils literal">new_passive</tt> operator, returning actually the initial state as it is</li>
<li>integrate specific constructs for code reflection</li>
<li>check that a class specified in <tt class="docutils literal">execute*With</tt> is indeed a (direct or not) mother class of this one, at least in debug mode</li>
<li>check that referenced attributes are legit (existing, not reserved, etc.)</li>
<li>support qualifier-based declarations of methods and attributes (<tt class="docutils literal">public</tt>, <tt class="docutils literal">protected</tt>, <tt class="docutils literal">private</tt>, <tt class="docutils literal">final</tt>, <tt class="docutils literal">const</tt>, etc.)</li>
</ul>
<!-- For WOOPER versions 2.0 and more recent: -->
<!-- - provide WOOPER constructs to define attributes thanks to the `Builder Design Pattern <http://en.wikipedia.org/wiki/Builder_pattern>`_ and/or factories -->
<!-- For hashtable-based versions of WOOPER: -->
<!-- - is **wooper_main_loop** (in ``wooper.hrl``) really tail-recursive? I think so -->
<!-- - would there be a **more efficient** implementation of hashtables? (ex: using proplists, process dictionary, generated modules, dict or ETS-based?); more generally speaking, some profiling could be done to further increase overall performances -->
<ul class="simple">
<li>even when pasting a template, having to declare all the new-related operators (ex: <tt class="docutils literal">new_link/N</tt>) is a bit tedious; an appropriate parse transform could do the trick and automate this declaration</li>
<li>ensure that all instances of a given class <em>reference</em> the same table dedicated to the method look-ups, and do not have each their own private <em>copy</em> of it (mere referencing is expected to result from single-assignment); storing a per-class direct method mapping could also be done with prebuilt modules: <tt class="docutils literal">class_Cat</tt> would rely on an automatically generated <tt class="docutils literal">class_Cat_mt</tt> (for &quot;method table&quot;) module, which would just be used in order to convert a method name in the name of the module that should be called in the context of that class, inheritance-wise; or, preferably, this information could be added directly to <tt class="docutils literal">class_Cat</tt></li>
</ul>
<!-- - ensure that each of these references remains purely *local* to the node (no network access wanted for method look-up!); this should be the case thanks to the local WOOPER class manager; otherwise, other types of tables could be used (maybe ETS) -->
<p></p>
</div>
<div class="section" id="licence">
<span id="free-software"></span><h2><a class="toc-backref" href="#id71">Licence</a></h2>
<p>WOOPER is licensed by its author (Olivier Boudeville) under a disjunctive tri-license giving you the choice of one of the three following sets of free software/open source licensing terms:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.mozilla.org/MPL/MPL-1.1.html">Mozilla Public License</a> (MPL), version 1.1 or later (very close to the former <a class="reference external" href="http://www.erlang.org/EPLICENSE">Erlang Public License</a>, except aspects regarding Ericsson and/or the Swedish law)</li>
<li><a class="reference external" href="http://www.gnu.org/licenses/gpl-3.0.html">GNU General Public License</a> (GPL), version 3.0 or later</li>
<li><a class="reference external" href="http://www.gnu.org/licenses/lgpl.html">GNU Lesser General Public License</a> (LGPL), version 3.0 or later</li>
</ul>
<p>This allows the use of the WOOPER code in as wide a variety of software projects as possible, while still maintaining copyleft on this code.</p>
<p>Being triple-licensed means that someone (the licensee) who modifies and/or distributes it can choose which of the available sets of licence terms he is operating under.</p>
<p>We hope that enhancements will be back-contributed (ex: thanks to merge requests), so that everyone will be able to benefit from them.</p>
<p></p>
</div>
<div class="section" id="sources-inspirations-alternate-solutions">
<h2><a class="toc-backref" href="#id72">Sources, Inspirations &amp; Alternate Solutions</a></h2>
<ul class="simple">
<li><strong>Concurrent Programming in Erlang</strong>, Joe Armstrong, Robert Virding, Claes Wikström et Mike Williams. Chapter 18, page 299: Object-oriented Programming. This book describes a simple way of implementing multiple inheritance, without virtual table, at the expense of a (probably slow) systematic method look-up (at each method call). No specific state management is supported</li>
<li>Chris Rathman's <a class="reference external" href="http://www.angelfire.com/tx4/cus/shapes/erlang.html">approach</a> to life cycle management and polymorphism. Inheritance not supported</li>
<li>As Burkhard Neppert suggested, an alternative way of implementing OOP here could be to use Erlang behaviours. This is the way OTP handles generic functionalities that can be specialised (e.g. <tt class="docutils literal">gen_server</tt>). One approach could be to map each object-oriented base class to an Erlang <strong>behaviour</strong>. See some guidelines about <a class="reference external" href="http://wiki.trapexit.org/index.php/Defining_Your_Own_Behaviour">defining</a> your own behaviours and making them <a class="reference external" href="http://wiki.trapexit.org/index.php/Cascading_Behaviours">cascade</a></li>
<li>As mentioned by Niclas Eklund, despite relying on quite different operating modes, WOOPER and <a class="reference external" href="http://www1.erlang.org/doc/apps/orber/index.html">Orber</a>, an Erlang implementation of a <strong>CORBA ORB</strong> (<em>Object Request Broker</em>) offer similar OOP features, as CORBA IDL implies an object-oriented approach (see their <a class="reference external" href="http://www.erlang.org/doc/apps/orber/ch_idl_to_erlang_mapping.html#6">OMG IDL to Erlang Mapping</a>)</li>
</ul>
<p>WOOPER and Orber are rather different beasts, though: WOOPER is very lightweight (less than 2300 lines, including blank lines and numerous comments), does not involve a specific (IDL) compiler generating several stub/skeleton Erlang files, nor depends on OTP or on Mnesia, whereas Orber offers a full CORBA implementation, including IDL language mapping, CosNaming, IIOP, Interface Repository, etc.</p>
<p>Since Orber respects the OMG standard, integrating a new language (C/C++, Java, Smalltalk, Ada, Lisp, Python etc.) should be rather easy. On the other hand, if a full-blown CORBA-compliant middleware is not needed, if simplicity and ease of understanding is a key point, then WOOPER could be preferred. If unsure, give a try to both!</p>
<p>See also another IDL-based approach (otherwise not connected to CORBA), the <a class="reference external" href="http://www.erlang.org/doc/apps/ic/ch_erl_genserv.html#5">Generic Server Back-end</a> (wrapper around <tt class="docutils literal">gen_server</tt>).</p>
<p>The WOOPER name is also a tribute to the vastly underrated <a class="reference external" href="http://en.wikipedia.org/wiki/WarGames">Wargames</a> movie (remember the <a class="reference external" href="http://en.wikipedia.org/wiki/WOPR">WOPR</a>, the NORAD central computer?) that the author enjoyed a lot. It is as well a second-order tribute to the <em>Double Whopper King Size</em>, which is a great hamburger indeed <a class="footnote-reference" href="#id28" id="id27">[10]</a>.</p>
<table class="docutils footnote" frame="void" id="id28" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id27">[10]</a></td><td>Provided of course one is fine with eating other animals (this is another topic).</td></tr>
</tbody>
</table>
<p></p>
</div>
<div class="section" id="support">
<h2><a class="toc-backref" href="#id73">Support</a></h2>
<p>Bugs, questions, remarks, patches, requests for enhancements, etc. are to be sent to the <a class="reference external" href="https://github.com/Olivier-Boudeville/Ceylan-WOOPER">project interface</a>, or directly at the mail address mentioned at the beginning of this longer document.</p>
<!-- For WOOPER Developers -->
<!-- ===================== -->
<!-- When a new WOOPER version is released, tag the corresponding file versions, like in:: -->
<!-- $ svn copy https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/trunk/src/code/scripts/erlang/wooper https://ceylan.svn.sourceforge.net/svnroot/ceylan/Ceylan/tags/wooper-release-0.1 -m "First release (0.1) of WOOPER, already fully functional." -->
</div>
<div class="section" id="please-react">
<h2><a class="toc-backref" href="#id74">Please React!</a></h2>
<p>If you have information more detailed or more recent than those presented in this document, if you noticed errors, neglects or points insufficiently discussed, drop us a line! (for that, follow the <a class="reference internal" href="#support">Support</a> guidelines).</p>
</div>
<div class="section" id="ending-word">
<h2><a class="toc-backref" href="#id75">Ending Word</a></h2>
<p>Have fun with WOOPER!</p>
<!-- comment Mostly added to ensure there is at least one figure directive, -->
<!-- otherwise the LateX graphic support will not be included: -->
<div class="figure">
<img alt="WOOPER logo" src="wooper-title.png" style="width: 384.40000000000003px; height: 78.0px;" />
</div>
<p><span class="raw-html"><a name="wooper_bottom"></a></span></p>
</div>
</div>
</div>
</body>
</html>
